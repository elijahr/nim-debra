{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#nim-debra","title":"nim-debra","text":"<p>DEBRA+ safe memory reclamation for lock-free data structures in Nim.</p>"},{"location":"#what-is-this","title":"What is this?","text":"<p>nim-debra implements the DEBRA+ algorithm (Distributed Epoch-Based Reclamation with Neutralization) for safe memory reclamation in lock-free concurrent data structures. It provides a compile-time typestate-enforced API that ensures correct usage of the reclamation protocol.</p> <pre><code>import debra\nimport std/atomics\n\n# Define your node type using ref Obj pattern\ntype\n  NodeObj = object\n    value: int\n    next: Atomic[Managed[ref NodeObj]]\n  Node = ref NodeObj\n\n# Initialize manager (one per process)\nvar manager = initDebraManager[64]()\nsetGlobalManager(addr manager)\n\n# Register thread (once per thread)\nlet handle = registerThread(manager)\n\n# Critical section - pin to protect memory access\nlet pinned = unpinned(handle).pin()\n# Create a managed node - GC won't collect until retired\nlet node = managed Node(value: 42)\n# ... safely access lock-free data structures ...\ndiscard pinned.unpin()\n\n# Retire objects when they're no longer needed\nlet ready = retireReady(pinned)\nlet retired = ready.retire(node)\n</code></pre> <p>The typestate system ensures you cannot accidentally access memory outside a critical section, retire objects without being pinned, or perform operations in the wrong order. If it compiles, the protocol is correct.</p>"},{"location":"#what-is-debra","title":"What is DEBRA+?","text":"<p>DEBRA+ is an epoch-based memory reclamation algorithm designed for lock-free data structures. Traditional garbage collection adds runtime overhead and unpredictable pauses. Manual memory management in concurrent code leads to use-after-free bugs and memory leaks.</p> <p>DEBRA+ solves this by:</p> <ul> <li>Epoch-based tracking: Global epoch counter advances as threads complete operations</li> <li>Pin/unpin protocol: Threads pin the current epoch while accessing shared data</li> <li>Safe reclamation: Objects retired in epoch E can be freed once all threads have moved past E</li> <li>Neutralization: Signal-based mechanism handles stalled threads to bound memory usage</li> </ul>"},{"location":"#why-typestates","title":"Why typestates?","text":"<p>This library uses nim-typestates to enforce the DEBRA+ protocol at compile time:</p> <ul> <li>Compile-time errors: Invalid operation sequences fail at compile time with clear error messages</li> <li>Self-documenting: Types show what operations are valid in each state</li> <li>Zero runtime cost: All validation happens during compilation</li> </ul> <p>For example, you cannot retire an object without being pinned:</p> <pre><code>let handle = registerThread(manager)\n# This won't compile - must pin first!\n# let ready = retireReady(handle)  # Error: handle is not Pinned\n\n# This is correct:\nlet pinned = unpinned(handle).pin()\nlet ready = retireReady(pinned)\nlet retired = ready.retire(node)\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Typestate-enforced API - Invalid operation sequences fail at compile time</li> <li>Signal-based neutralization - Handles stalled threads for bounded memory usage</li> <li>Limbo bags - Thread-local retire queues organized in 64-object batches</li> <li>Managed[T] wrapper - Works with any <code>ref</code> type, integrates with Nim's GC</li> <li>O(mn) memory bound - Where m = threads, n = objects per epoch</li> <li>Zero runtime overhead - Typestate validation happens at compile time</li> </ul>"},{"location":"#memory-reclamation-workflow","title":"Memory Reclamation Workflow","text":"<ol> <li>Manager initialization: Create and initialize a <code>DebraManager[MaxThreads]</code></li> <li>Thread registration: Each thread registers to get a <code>ThreadHandle</code></li> <li>Pin epoch: Enter critical section with <code>pin()</code> to get <code>Pinned</code> state</li> <li>Access shared data: Safely read/write lock-free data structures</li> <li>Retire objects: Mark removed objects for reclamation with <code>retire()</code></li> <li>Unpin epoch: Exit critical section with <code>unpin()</code></li> <li>Reclamation: Background process reclaims objects from old epochs</li> </ol>"},{"location":"#installation","title":"Installation","text":"<pre><code>nimble install debra\n</code></pre> <p>Or add to your <code>.nimble</code> file:</p> <pre><code>requires \"debra &gt;= 0.1.0\"\n</code></pre>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Getting Started - Tutorial walkthrough</li> <li>Concepts - Understanding DEBRA+ algorithm</li> <li>API Reference - Generated API documentation</li> </ul>"},{"location":"#references","title":"References","text":""},{"location":"#foundational-papers","title":"Foundational Papers","text":"<ul> <li>DEBRA+: Efficient Memory Reclamation (Brown, 2017) - The DEBRA+ algorithm with signal-based neutralization</li> <li>Epoch-Based Reclamation (Fraser, 2004) - Original epoch-based memory reclamation approach</li> </ul>"},{"location":"#related-projects","title":"Related Projects","text":"<ul> <li>nim-typestates - Compile-time typestate validation library used by nim-debra</li> <li>lockfreequeues - Lock-free queue implementations using nim-debra for memory reclamation</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#api-reference","title":"API Reference","text":"<p>Auto-generated API documentation from source code.</p>"},{"location":"api/#main-module","title":"Main Module","text":""},{"location":"api/#debra","title":"debra","text":"<p>nim-debra: DEBRA+ Safe Memory Reclamation</p> <p>This library provides typestate-enforced epoch-based reclamation with signal-based neutralization for lock-free data structures.</p>"},{"location":"api/#registerThread","title":"registerThread raises","text":"<pre><code>proc registerThread(manager: var DebraManager[MaxThreads]): ThreadHandle[MaxThreads]</code></pre> <p>Register current thread with the DEBRA manager.</p> <p>Must be called once per thread before any epoch operations. Raises DebraRegistrationError if max threads already registered.</p> Parameters <ul> <li> <code>manager</code>               (<code>var DebraManager[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ThreadHandle[MaxThreads]</code></p> Raises <ul> <li><code>DebraRegistrationError</code></li> </ul> Source:              src/debra.nim:42"},{"location":"api/#neutralizeStalled","title":"neutralizeStalled","text":"<pre><code>proc neutralizeStalled(manager: var DebraManager[MaxThreads]; epochsBeforeNeutralize: uint64 = 2): int</code></pre> <p>Signal all stalled threads. Returns number of signals sent.</p> Parameters <ul> <li> <code>manager</code>               (<code>var DebraManager[MaxThreads]</code>)                            </li> <li> <code>epochsBeforeNeutralize</code>               (<code>uint64</code>)                            </li> </ul> Returns <p><code>int</code></p> Source:              src/debra.nim:61"},{"location":"api/#advance","title":"advance inline","text":"<pre><code>proc advance(manager: var DebraManager[MaxThreads])</code></pre> <p>Advance the global epoch.</p> Parameters <ul> <li> <code>manager</code>               (<code>var DebraManager[MaxThreads]</code>)                            </li> </ul> Source:              src/debra.nim:70"},{"location":"api/#currentEpoch","title":"currentEpoch inline","text":"<pre><code>proc currentEpoch(manager: var DebraManager[MaxThreads]): uint64</code></pre> <p>Get current global epoch.</p> Parameters <ul> <li> <code>manager</code>               (<code>var DebraManager[MaxThreads]</code>)                            </li> </ul> Returns <p><code>uint64</code></p> Source:              src/debra.nim:76"},{"location":"api/#core-types","title":"Core Types","text":"<p>Type definitions for DEBRA+ manager and thread state.</p>"},{"location":"api/#types","title":"types","text":"<p>Core types for DEBRA+ implementation.</p>"},{"location":"api/#ThreadState","title":"ThreadState","text":"<pre><code>type ThreadState</code></pre> Source:              src/debra/types.nim:12"},{"location":"api/#DebraManager","title":"DebraManager","text":"<pre><code>type DebraManager</code></pre> Source:              src/debra/types.nim:25"},{"location":"api/#ThreadHandle","title":"ThreadHandle","text":"<pre><code>type ThreadHandle</code></pre> Source:              src/debra/types.nim:32"},{"location":"api/#DebraRegistrationError","title":"DebraRegistrationError","text":"<pre><code>type DebraRegistrationError</code></pre> Source:              src/debra/types.nim:37"},{"location":"api/#initDebraManager","title":"initDebraManager","text":"<pre><code>proc initDebraManager(): DebraManager[MaxThreads]</code></pre> <p>Initialize a new DEBRA+ manager.</p> <p>The global epoch starts at 1 (not 0) so that epoch 0 can represent \"never observed\" in thread state.</p> Returns <p><code>DebraManager[MaxThreads]</code></p> Source:              src/debra/types.nim:40"},{"location":"api/#constants_1","title":"Constants","text":"<p>Configuration constants for DEBRA+ algorithm.</p>"},{"location":"api/#constants","title":"constants","text":"<p>Constants for DEBRA+ implementation.</p>"},{"location":"api/#DefaultMaxThreads","title":"DefaultMaxThreads","text":"<pre><code>const DefaultMaxThreads</code></pre> <p>Default maximum number of threads that can be registered.</p> Source:              src/debra/constants.nim:6"},{"location":"api/#CacheLineBytes","title":"CacheLineBytes","text":"<pre><code>const CacheLineBytes</code></pre> <p>Cache line size for alignment to prevent false sharing.</p> Source:              src/debra/constants.nim:8"},{"location":"api/#limbo-bags","title":"Limbo Bags","text":"<p>Data structures for thread-local retire queues.</p>"},{"location":"api/#limbo","title":"limbo","text":"<p>Limbo bag data structures for DEBRA+ retire queues.</p> <p>A limbo bag holds up to 64 retired objects. Bags are linked together forming a thread-local retire queue.</p>"},{"location":"api/#LimboBagSize","title":"LimboBagSize","text":"<pre><code>const LimboBagSize</code></pre> Source:              src/debra/limbo.nim:9"},{"location":"api/#Destructor","title":"Destructor","text":"<pre><code>type Destructor</code></pre> Source:              src/debra/limbo.nim:12"},{"location":"api/#RetiredObject","title":"RetiredObject","text":"<pre><code>type RetiredObject</code></pre> Source:              src/debra/limbo.nim:14"},{"location":"api/#LimboBag","title":"LimboBag","text":"<pre><code>type LimboBag</code></pre> Source:              src/debra/limbo.nim:18"},{"location":"api/#allocLimboBag","title":"allocLimboBag","text":"<pre><code>proc allocLimboBag(): ptr LimboBag</code></pre> <p>Allocate a new empty limbo bag.</p> Returns <p><code>ptr LimboBag</code></p> Source:              src/debra/limbo.nim:24"},{"location":"api/#freeLimboBag","title":"freeLimboBag","text":"<pre><code>proc freeLimboBag(bag: ptr LimboBag)</code></pre> <p>Free a limbo bag (does NOT call destructors).</p> Parameters <ul> <li> <code>bag</code>               (<code>ptr LimboBag</code>)                            </li> </ul> Source:              src/debra/limbo.nim:28"},{"location":"api/#reclaimBag","title":"reclaimBag","text":"<pre><code>proc reclaimBag(bag: ptr LimboBag)</code></pre> <p>Call destructors for all objects in bag, then free bag.</p> Parameters <ul> <li> <code>bag</code>               (<code>ptr LimboBag</code>)                            </li> </ul> Source:              src/debra/limbo.nim:32"},{"location":"api/#unreffer","title":"unreffer","text":"<pre><code>proc unreffer(): Destructor</code></pre> <p>Generate a destructor that calls GC_unref for type T.</p> <p>Used internally by retire() to create type-specific destructors for Managed[T] objects.</p> Returns <p><code>Destructor</code></p> Source:              src/debra/limbo.nim:40"},{"location":"api/#signal-handling","title":"Signal Handling","text":"<p>POSIX signal handling for neutralization protocol.</p>"},{"location":"api/#signal","title":"signal","text":"<p>Signal handler for DEBRA+ thread neutralization.</p> <p>When a thread is stalled (hasn't advanced its epoch), other threads can send SIGUSR1 to force it to unpin, allowing reclamation to proceed.</p>"},{"location":"api/#installSignalHandler","title":"installSignalHandler","text":"<pre><code>proc installSignalHandler()</code></pre> <p>Install SIGUSR1 handler for DEBRA+ neutralization.</p> <p>Safe to call multiple times - subsequent calls are no-ops. Called automatically during first DebraManager initialization.</p> Source:              src/debra/signal.nim:54"},{"location":"api/#isSignalHandlerInstalled","title":"isSignalHandlerInstalled","text":"<pre><code>proc isSignalHandlerInstalled(): bool</code></pre> <p>Check if signal handler has been installed.</p> Returns <p><code>bool</code></p> Source:              src/debra/signal.nim:70"},{"location":"api/#setGlobalManager","title":"setGlobalManager","text":"<pre><code>proc setGlobalManager(manager: pointer)</code></pre> <p>Set the global manager pointer for signal handler.</p> <p>Must be called once after manager initialization.</p> Parameters <ul> <li> <code>manager</code>               (<code>pointer</code>)                            </li> </ul> Source:              src/debra/signal.nim:74"},{"location":"api/#typestates","title":"Typestates","text":""},{"location":"api/#signal-handler","title":"Signal Handler","text":"<p>Signal handler installation lifecycle.</p>"},{"location":"api/#signal_handler","title":"signal_handler","text":"<p>SignalHandler typestate.</p> <p>Ensures signal handler is installed before DEBRA operations.</p>"},{"location":"api/#SignalHandlerContext","title":"SignalHandlerContext","text":"<pre><code>type SignalHandlerContext</code></pre> Source:              src/debra/typestates/signal_handler.nim:11"},{"location":"api/#HandlerUninstalled","title":"HandlerUninstalled","text":"<pre><code>type HandlerUninstalled</code></pre> Source:              src/debra/typestates/signal_handler.nim:14"},{"location":"api/#HandlerInstalled","title":"HandlerInstalled","text":"<pre><code>type HandlerInstalled</code></pre> Source:              src/debra/typestates/signal_handler.nim:15"},{"location":"api/#initSignalHandler","title":"initSignalHandler","text":"<pre><code>proc initSignalHandler(): HandlerUninstalled</code></pre> <p>Create uninstalled signal handler context.</p> Returns <p><code>HandlerUninstalled</code></p> Source:              src/debra/typestates/signal_handler.nim:27"},{"location":"api/#install","title":"install transition","text":"<pre><code>proc install(h: HandlerUninstalled): HandlerInstalled</code></pre> <p>Install SIGUSR1 handler for DEBRA+ neutralization.</p> Parameters <ul> <li> <code>h</code>               (<code>HandlerUninstalled</code>)                            </li> </ul> Returns <p><code>HandlerInstalled</code></p> Source:              src/debra/typestates/signal_handler.nim:31"},{"location":"api/#isInstalled","title":"isInstalled","text":"<pre><code>func isInstalled(h: HandlerInstalled): bool</code></pre> <p>Check if handler is installed.</p> Parameters <ul> <li> <code>h</code>               (<code>HandlerInstalled</code>)                            </li> </ul> Returns <p><code>bool</code></p> Source:              src/debra/typestates/signal_handler.nim:40"},{"location":"api/#manager_1","title":"Manager","text":"<p>Manager initialization and shutdown lifecycle.</p>"},{"location":"api/#manager","title":"manager","text":"<p>DebraManager lifecycle typestate.</p> <p>Ensures manager is initialized before use and properly shut down.</p>"},{"location":"api/#ManagerContext","title":"ManagerContext","text":"<pre><code>type ManagerContext</code></pre> Source:              src/debra/typestates/manager.nim:13"},{"location":"api/#ManagerUninitialized","title":"ManagerUninitialized","text":"<pre><code>type ManagerUninitialized</code></pre> Source:              src/debra/typestates/manager.nim:16"},{"location":"api/#ManagerReady","title":"ManagerReady","text":"<pre><code>type ManagerReady</code></pre> Source:              src/debra/typestates/manager.nim:17"},{"location":"api/#ManagerShutdown","title":"ManagerShutdown","text":"<pre><code>type ManagerShutdown</code></pre> Source:              src/debra/typestates/manager.nim:18"},{"location":"api/#uninitializedManager","title":"uninitializedManager","text":"<pre><code>proc uninitializedManager(mgr: ptr DebraManager[MaxThreads]): ManagerUninitialized[MaxThreads]</code></pre> <p>Wrap a manager pointer as uninitialized.</p> Parameters <ul> <li> <code>mgr</code>               (<code>ptr DebraManager[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ManagerUninitialized[MaxThreads]</code></p> Source:              src/debra/typestates/manager.nim:28"},{"location":"api/#initialize","title":"initialize transition","text":"<pre><code>proc initialize(m: sink ManagerUninitialized[MaxThreads]): ManagerReady[MaxThreads]</code></pre> <p>Initialize the manager. Sets epoch to 1, clears all state.</p> Parameters <ul> <li> <code>m</code>               (<code>sink ManagerUninitialized[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ManagerReady[MaxThreads]</code></p> Source:              src/debra/typestates/manager.nim:34"},{"location":"api/#shutdown","title":"shutdown transition","text":"<pre><code>proc shutdown(m: sink ManagerReady[MaxThreads]): ManagerShutdown[MaxThreads]</code></pre> <p>Shutdown manager. Reclaims all remaining limbo bags.</p> Parameters <ul> <li> <code>m</code>               (<code>sink ManagerReady[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ManagerShutdown[MaxThreads]</code></p> Source:              src/debra/typestates/manager.nim:52"},{"location":"api/#getManager","title":"getManager","text":"<pre><code>func getManager(m: ManagerReady[MaxThreads]): ptr DebraManager[MaxThreads]</code></pre> <p>Get the underlying manager pointer.</p> Parameters <ul> <li> <code>m</code>               (<code>ManagerReady[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ptr DebraManager[MaxThreads]</code></p> Source:              src/debra/typestates/manager.nim:73"},{"location":"api/#registration_1","title":"Registration","text":"<p>Thread registration lifecycle.</p>"},{"location":"api/#registration","title":"registration","text":"<p>Registration typestate for thread registration.</p> <p>Handles thread registration with the DEBRA manager, ensuring threads properly claim slots in the thread array using lock-free CAS operations.</p>"},{"location":"api/#RegistrationContext","title":"RegistrationContext","text":"<pre><code>type RegistrationContext</code></pre> Source:              src/debra/typestates/registration.nim:14"},{"location":"api/#Unregistered","title":"Unregistered","text":"<pre><code>type Unregistered</code></pre> Source:              src/debra/typestates/registration.nim:18"},{"location":"api/#Registered","title":"Registered","text":"<pre><code>type Registered</code></pre> Source:              src/debra/typestates/registration.nim:19"},{"location":"api/#RegistrationFull","title":"RegistrationFull","text":"<pre><code>type RegistrationFull</code></pre> Source:              src/debra/typestates/registration.nim:20"},{"location":"api/#unregistered","title":"unregistered","text":"<pre><code>proc unregistered(mgr: ptr DebraManager[MaxThreads]): Unregistered[MaxThreads]</code></pre> <p>Create unregistered context for a thread.</p> Parameters <ul> <li> <code>mgr</code>               (<code>ptr DebraManager[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Unregistered[MaxThreads]</code></p> Source:              src/debra/typestates/registration.nim:31"},{"location":"api/#register","title":"register transition","text":"<pre><code>proc register(u: sink Unregistered[MaxThreads]): RegisterResult[MaxThreads]</code></pre> <p>Try to register thread by claiming a slot. Returns Registered if successful, RegistrationFull if all slots are taken.</p> Parameters <ul> <li> <code>u</code>               (<code>sink Unregistered[MaxThreads]</code>)                            </li> </ul> Returns <p><code>RegisterResult[MaxThreads]</code></p> Source:              src/debra/typestates/registration.nim:37"},{"location":"api/#idx","title":"idx","text":"<pre><code>func idx(r: Registered[MaxThreads]): int</code></pre> <p>Get the thread slot index.</p> Parameters <ul> <li> <code>r</code>               (<code>Registered[MaxThreads]</code>)                            </li> </ul> Returns <p><code>int</code></p> Source:              src/debra/typestates/registration.nim:70"},{"location":"api/#getHandle","title":"getHandle","text":"<pre><code>func getHandle(r: Registered[MaxThreads]): ThreadHandle[MaxThreads]</code></pre> <p>Extract ThreadHandle for use in pin/unpin operations.</p> Parameters <ul> <li> <code>r</code>               (<code>Registered[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ThreadHandle[MaxThreads]</code></p> Source:              src/debra/typestates/registration.nim:74"},{"location":"api/#thread-slot","title":"Thread Slot","text":"<p>Thread slot allocation and release.</p>"},{"location":"api/#slot","title":"slot","text":"<p>ThreadSlot typestate for thread slot lifecycle.</p> <p>Tracks the lifecycle of a thread slot in the DEBRA manager: - Free: Slot is available for claiming - Claiming: Thread is attempting to claim the slot - Active: Slot is actively in use by a thread - Draining: Thread is unregistering, draining limbo bags - Free: Slot released back to pool</p>"},{"location":"api/#SlotContext","title":"SlotContext","text":"<pre><code>type SlotContext</code></pre> Source:              src/debra/typestates/slot.nim:15"},{"location":"api/#Free","title":"Free","text":"<pre><code>type Free</code></pre> Source:              src/debra/typestates/slot.nim:19"},{"location":"api/#Claiming","title":"Claiming","text":"<pre><code>type Claiming</code></pre> Source:              src/debra/typestates/slot.nim:20"},{"location":"api/#Active","title":"Active","text":"<pre><code>type Active</code></pre> Source:              src/debra/typestates/slot.nim:21"},{"location":"api/#Draining","title":"Draining","text":"<pre><code>type Draining</code></pre> Source:              src/debra/typestates/slot.nim:22"},{"location":"api/#freeSlot","title":"freeSlot","text":"<pre><code>proc freeSlot(idx: int; mgr: ptr DebraManager[MaxThreads]): Free[MaxThreads]</code></pre> <p>Create a free slot context.</p> Parameters <ul> <li> <code>idx</code>               (<code>int</code>)                            </li> <li> <code>mgr</code>               (<code>ptr DebraManager[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Free[MaxThreads]</code></p> Source:              src/debra/typestates/slot.nim:34"},{"location":"api/#claim","title":"claim transition","text":"<pre><code>proc claim(f: sink Free[MaxThreads]): Claiming[MaxThreads]</code></pre> <p>Begin claiming this slot. Transition to Claiming state.</p> Parameters <ul> <li> <code>f</code>               (<code>sink Free[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Claiming[MaxThreads]</code></p> Source:              src/debra/typestates/slot.nim:40"},{"location":"api/#activate","title":"activate transition","text":"<pre><code>proc activate(c: sink Claiming[MaxThreads]): Active[MaxThreads]</code></pre> <p>Complete slot claim. Transition to Active state. This is where the slot becomes fully owned by a thread.</p> Parameters <ul> <li> <code>c</code>               (<code>sink Claiming[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Active[MaxThreads]</code></p> Source:              src/debra/typestates/slot.nim:46"},{"location":"api/#drain","title":"drain transition","text":"<pre><code>proc drain(a: sink Active[MaxThreads]): Draining[MaxThreads]</code></pre> <p>Begin unregistration. Transition to Draining state. Thread will drain its limbo bags before releasing the slot.</p> Parameters <ul> <li> <code>a</code>               (<code>sink Active[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Draining[MaxThreads]</code></p> Source:              src/debra/typestates/slot.nim:53"},{"location":"api/#release","title":"release transition","text":"<pre><code>proc release(d: sink Draining[MaxThreads]): Free[MaxThreads]</code></pre> <p>Release slot back to free pool. Transition back to Free state. This completes the lifecycle, making the slot available for reuse.</p> Parameters <ul> <li> <code>d</code>               (<code>sink Draining[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Free[MaxThreads]</code></p> Source:              src/debra/typestates/slot.nim:60"},{"location":"api/#idx","title":"idx","text":"<pre><code>func idx(s: Active[MaxThreads]): int</code></pre> <p>Get the slot index from Active state.</p> Parameters <ul> <li> <code>s</code>               (<code>Active[MaxThreads]</code>)                            </li> </ul> Returns <p><code>int</code></p> Source:              src/debra/typestates/slot.nim:67"},{"location":"api/#idx","title":"idx","text":"<pre><code>func idx(s: Draining[MaxThreads]): int</code></pre> <p>Get the slot index from Draining state.</p> Parameters <ul> <li> <code>s</code>               (<code>Draining[MaxThreads]</code>)                            </li> </ul> Returns <p><code>int</code></p> Source:              src/debra/typestates/slot.nim:71"},{"location":"api/#manager","title":"manager","text":"<pre><code>func manager(s: Active[MaxThreads]): ptr DebraManager[MaxThreads]</code></pre> <p>Get the manager pointer from Active state.</p> Parameters <ul> <li> <code>s</code>               (<code>Active[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ptr DebraManager[MaxThreads]</code></p> Source:              src/debra/typestates/slot.nim:75"},{"location":"api/#manager","title":"manager","text":"<pre><code>func manager(s: Draining[MaxThreads]): ptr DebraManager[MaxThreads]</code></pre> <p>Get the manager pointer from Draining state.</p> Parameters <ul> <li> <code>s</code>               (<code>Draining[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ptr DebraManager[MaxThreads]</code></p> Source:              src/debra/typestates/slot.nim:81"},{"location":"api/#epoch-guard","title":"Epoch Guard","text":"<p>Pin/unpin critical section lifecycle.</p>"},{"location":"api/#guard","title":"guard","text":"<p>EpochGuard typestate for pin/unpin lifecycle.</p> <p>Ensures threads properly enter/exit critical sections.</p>"},{"location":"api/#EpochGuardContext","title":"EpochGuardContext","text":"<pre><code>type EpochGuardContext</code></pre> Source:              src/debra/typestates/guard.nim:11"},{"location":"api/#Unpinned","title":"Unpinned","text":"<pre><code>type Unpinned</code></pre> Source:              src/debra/typestates/guard.nim:15"},{"location":"api/#Pinned","title":"Pinned","text":"<pre><code>type Pinned</code></pre> Source:              src/debra/typestates/guard.nim:16"},{"location":"api/#Neutralized","title":"Neutralized","text":"<pre><code>type Neutralized</code></pre> Source:              src/debra/typestates/guard.nim:17"},{"location":"api/#unpinned","title":"unpinned","text":"<pre><code>proc unpinned(handle: ThreadHandle[MaxThreads]): Unpinned[MaxThreads]</code></pre> <p>Create unpinned epoch guard context.</p> Parameters <ul> <li> <code>handle</code>               (<code>ThreadHandle[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Unpinned[MaxThreads]</code></p> Source:              src/debra/typestates/guard.nim:29"},{"location":"api/#pin","title":"pin transition","text":"<pre><code>proc pin(u: sink Unpinned[MaxThreads]): Pinned[MaxThreads]</code></pre> <p>Enter critical section. Blocks reclamation of current epoch.</p> Parameters <ul> <li> <code>u</code>               (<code>sink Unpinned[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Pinned[MaxThreads]</code></p> Source:              src/debra/typestates/guard.nim:35"},{"location":"api/#unpin","title":"unpin transition","text":"<pre><code>proc unpin(p: sink Pinned[MaxThreads]): UnpinResult[MaxThreads]</code></pre> <p>Leave critical section. Returns Neutralized if signaled.</p> Parameters <ul> <li> <code>p</code>               (<code>sink Pinned[MaxThreads]</code>)                            </li> </ul> Returns <p><code>UnpinResult[MaxThreads]</code></p> Source:              src/debra/typestates/guard.nim:50"},{"location":"api/#acknowledge","title":"acknowledge transition","text":"<pre><code>proc acknowledge(n: sink Neutralized[MaxThreads]): Unpinned[MaxThreads]</code></pre> <p>Acknowledge neutralization. Required before re-pinning.</p> Parameters <ul> <li> <code>n</code>               (<code>sink Neutralized[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Unpinned[MaxThreads]</code></p> Source:              src/debra/typestates/guard.nim:65"},{"location":"api/#epoch","title":"epoch","text":"<pre><code>func epoch(p: Pinned[MaxThreads]): uint64</code></pre> <p>Get the epoch this thread is pinned at.</p> Parameters <ul> <li> <code>p</code>               (<code>Pinned[MaxThreads]</code>)                            </li> </ul> Returns <p><code>uint64</code></p> Source:              src/debra/typestates/guard.nim:73"},{"location":"api/#handle","title":"handle","text":"<pre><code>func handle(p: Pinned[MaxThreads]): ThreadHandle[MaxThreads]</code></pre> <p>Get the thread handle.</p> Parameters <ul> <li> <code>p</code>               (<code>Pinned[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ThreadHandle[MaxThreads]</code></p> Source:              src/debra/typestates/guard.nim:77"},{"location":"api/#retire_1","title":"Retire","text":"<p>Object retirement to limbo bags.</p>"},{"location":"api/#retire","title":"retire","text":"<p>Retire typestate for adding objects to limbo bags.</p> <p>Must be pinned to retire objects.</p>"},{"location":"api/#RetireContext","title":"RetireContext","text":"<pre><code>type RetireContext</code></pre> Source:              src/debra/typestates/retire.nim:13"},{"location":"api/#RetireReady","title":"RetireReady","text":"<pre><code>type RetireReady</code></pre> Source:              src/debra/typestates/retire.nim:17"},{"location":"api/#Retired","title":"Retired","text":"<pre><code>type Retired</code></pre> Source:              src/debra/typestates/retire.nim:18"},{"location":"api/#retireReady","title":"retireReady","text":"<pre><code>proc retireReady(p: Pinned[MaxThreads]): RetireReady[MaxThreads]</code></pre> <p>Create retire context from pinned state.</p> Parameters <ul> <li> <code>p</code>               (<code>Pinned[MaxThreads]</code>)                            </li> </ul> Returns <p><code>RetireReady[MaxThreads]</code></p> Source:              src/debra/typestates/retire.nim:26"},{"location":"api/#retireReadyFromRetired","title":"retireReadyFromRetired","text":"<pre><code>proc retireReadyFromRetired(r: sink Retired[MaxThreads]): RetireReady[MaxThreads]</code></pre> <p>Get back to RetireReady after retiring (for multiple retires).</p> Parameters <ul> <li> <code>r</code>               (<code>sink Retired[MaxThreads]</code>)                            </li> </ul> Returns <p><code>RetireReady[MaxThreads]</code></p> Source:              src/debra/typestates/retire.nim:32"},{"location":"api/#retire","title":"retire transition","text":"<pre><code>proc retire(r: sink RetireReady[MaxThreads]; obj: Managed[T]): Retired[MaxThreads]</code></pre> <p>Retire a managed object for epoch-based reclamation.</p> <p>The object will be freed (via GC_unref) when its epoch becomes safe for reclamation.</p> Parameters <ul> <li> <code>r</code>               (<code>sink RetireReady[MaxThreads]</code>)                            </li> <li> <code>obj</code>               (<code>Managed[T]</code>)                            </li> </ul> Returns <p><code>Retired[MaxThreads]</code></p> Source:              src/debra/typestates/retire.nim:38"},{"location":"api/#retire","title":"retire transition","text":"<pre><code>proc retire(r: sink RetireReady[MaxThreads]; p: pointer; destructor: Destructor): Retired[MaxThreads]</code></pre> <p>Retire a raw pointer for epoch-based reclamation.</p> <p>The destructor will be called when the epoch becomes safe. Use for manually-managed memory (ptr types, alloc/dealloc, etc.)</p> Parameters <ul> <li> <code>r</code>               (<code>sink RetireReady[MaxThreads]</code>)                            </li> <li> <code>p</code>               (<code>pointer</code>)                            </li> <li> <code>destructor</code>               (<code>Destructor</code>)                            </li> </ul> Returns <p><code>Retired[MaxThreads]</code></p> Source:              src/debra/typestates/retire.nim:71"},{"location":"api/#handle","title":"handle","text":"<pre><code>func handle(r: RetireReady[MaxThreads]): ThreadHandle[MaxThreads]</code></pre> Parameters <ul> <li> <code>r</code>               (<code>RetireReady[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ThreadHandle[MaxThreads]</code></p> Source:              src/debra/typestates/retire.nim:103"},{"location":"api/#reclamation","title":"Reclamation","text":"<p>Safe memory reclamation from limbo bags.</p>"},{"location":"api/#reclaim","title":"reclaim","text":"<p>Reclaim typestate for safe memory reclamation.</p> <p>Walks limbo bags and reclaims objects retired before safeEpoch.</p>"},{"location":"api/#ReclaimContext","title":"ReclaimContext","text":"<pre><code>type ReclaimContext</code></pre> Source:              src/debra/typestates/reclaim.nim:12"},{"location":"api/#ReclaimStart","title":"ReclaimStart","text":"<pre><code>type ReclaimStart</code></pre> Source:              src/debra/typestates/reclaim.nim:17"},{"location":"api/#EpochsLoaded","title":"EpochsLoaded","text":"<pre><code>type EpochsLoaded</code></pre> Source:              src/debra/typestates/reclaim.nim:18"},{"location":"api/#ReclaimReady","title":"ReclaimReady","text":"<pre><code>type ReclaimReady</code></pre> Source:              src/debra/typestates/reclaim.nim:19"},{"location":"api/#ReclaimBlocked","title":"ReclaimBlocked","text":"<pre><code>type ReclaimBlocked</code></pre> Source:              src/debra/typestates/reclaim.nim:20"},{"location":"api/#reclaimStart","title":"reclaimStart","text":"<pre><code>proc reclaimStart(mgr: ptr DebraManager[MaxThreads]): ReclaimStart[MaxThreads]</code></pre> <p>Begin reclamation attempt.</p> Parameters <ul> <li> <code>mgr</code>               (<code>ptr DebraManager[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ReclaimStart[MaxThreads]</code></p> Source:              src/debra/typestates/reclaim.nim:31"},{"location":"api/#loadEpochs","title":"loadEpochs transition","text":"<pre><code>proc loadEpochs(s: ReclaimStart[MaxThreads]): EpochsLoaded[MaxThreads]</code></pre> <p>Load global epoch and compute minimum epoch across pinned threads.</p> Parameters <ul> <li> <code>s</code>               (<code>ReclaimStart[MaxThreads]</code>)                            </li> </ul> Returns <p><code>EpochsLoaded[MaxThreads]</code></p> Source:              src/debra/typestates/reclaim.nim:39"},{"location":"api/#safeEpoch","title":"safeEpoch","text":"<pre><code>func safeEpoch(e: EpochsLoaded[MaxThreads]): uint64</code></pre> Parameters <ul> <li> <code>e</code>               (<code>EpochsLoaded[MaxThreads]</code>)                            </li> </ul> Returns <p><code>uint64</code></p> Source:              src/debra/typestates/reclaim.nim:55"},{"location":"api/#checkSafe","title":"checkSafe transition","text":"<pre><code>proc checkSafe(e: EpochsLoaded[MaxThreads]): ReclaimCheck[MaxThreads]</code></pre> <p>Check if any epochs are safe to reclaim.</p> Parameters <ul> <li> <code>e</code>               (<code>EpochsLoaded[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ReclaimCheck[MaxThreads]</code></p> Source:              src/debra/typestates/reclaim.nim:58"},{"location":"api/#tryReclaim","title":"tryReclaim notATransition","text":"<pre><code>proc tryReclaim(r: ReclaimReady[MaxThreads]): int</code></pre> <p>Reclaim all eligible objects from all threads' limbo bags. Returns count of objects reclaimed.</p> Parameters <ul> <li> <code>r</code>               (<code>ReclaimReady[MaxThreads]</code>)                            </li> </ul> Returns <p><code>int</code></p> Source:              src/debra/typestates/reclaim.nim:68"},{"location":"api/#neutralization","title":"Neutralization","text":"<p>Thread neutralization protocol.</p>"},{"location":"api/#neutralize","title":"neutralize","text":"<p>Neutralize typestate for DEBRA+ neutralization signaling.</p> <p>Ensures proper sequence: ScanStart -&gt; Scanning -&gt; ScanComplete</p> <p>When the epoch needs to advance, scan all threads and send SIGUSR1 to pinned threads that are stalled (behind globalEpoch by threshold).</p>"},{"location":"api/#NeutralizeContext","title":"NeutralizeContext","text":"<pre><code>type NeutralizeContext</code></pre> Source:              src/debra/typestates/neutralize.nim:16"},{"location":"api/#ScanStart","title":"ScanStart","text":"<pre><code>type ScanStart</code></pre> Source:              src/debra/typestates/neutralize.nim:22"},{"location":"api/#Scanning","title":"Scanning","text":"<pre><code>type Scanning</code></pre> Source:              src/debra/typestates/neutralize.nim:23"},{"location":"api/#ScanComplete","title":"ScanComplete","text":"<pre><code>type ScanComplete</code></pre> Source:              src/debra/typestates/neutralize.nim:24"},{"location":"api/#scanStart","title":"scanStart","text":"<pre><code>proc scanStart(mgr: ptr DebraManager[MaxThreads]): ScanStart[MaxThreads]</code></pre> <p>Begin neutralization scan.</p> Parameters <ul> <li> <code>mgr</code>               (<code>ptr DebraManager[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ScanStart[MaxThreads]</code></p> Source:              src/debra/typestates/neutralize.nim:33"},{"location":"api/#loadEpoch","title":"loadEpoch transition","text":"<pre><code>proc loadEpoch(s: ScanStart[MaxThreads]; epochsBeforeNeutralize: uint64 = 2): Scanning[MaxThreads]</code></pre> <p>Load global epoch and compute threshold for stalled threads. Threads with epoch &lt; (globalEpoch - epochsBeforeNeutralize) get signaled.</p> Parameters <ul> <li> <code>s</code>               (<code>ScanStart[MaxThreads]</code>)                            </li> <li> <code>epochsBeforeNeutralize</code>               (<code>uint64</code>)                            </li> </ul> Returns <p><code>Scanning[MaxThreads]</code></p> Source:              src/debra/typestates/neutralize.nim:43"},{"location":"api/#globalEpoch","title":"globalEpoch","text":"<pre><code>func globalEpoch(s: Scanning[MaxThreads]): uint64</code></pre> <p>Get the global epoch loaded during scan start.</p> Parameters <ul> <li> <code>s</code>               (<code>Scanning[MaxThreads]</code>)                            </li> </ul> Returns <p><code>uint64</code></p> Source:              src/debra/typestates/neutralize.nim:59"},{"location":"api/#threshold","title":"threshold","text":"<pre><code>func threshold(s: Scanning[MaxThreads]): uint64</code></pre> <p>Get the epoch threshold for neutralization.</p> Parameters <ul> <li> <code>s</code>               (<code>Scanning[MaxThreads]</code>)                            </li> </ul> Returns <p><code>uint64</code></p> Source:              src/debra/typestates/neutralize.nim:63"},{"location":"api/#scanAndSignal","title":"scanAndSignal transition","text":"<pre><code>proc scanAndSignal(s: Scanning[MaxThreads]): ScanComplete[MaxThreads]</code></pre> <p>Scan all registered threads and send SIGUSR1 to stalled pinned threads. Returns count of signals sent.</p> Parameters <ul> <li> <code>s</code>               (<code>Scanning[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ScanComplete[MaxThreads]</code></p> Source:              src/debra/typestates/neutralize.nim:67"},{"location":"api/#signalsSent","title":"signalsSent","text":"<pre><code>func signalsSent(c: ScanComplete[MaxThreads]): int</code></pre> <p>Get number of signals sent during scan.</p> Parameters <ul> <li> <code>c</code>               (<code>ScanComplete[MaxThreads]</code>)                            </li> </ul> Returns <p><code>int</code></p> Source:              src/debra/typestates/neutralize.nim:92"},{"location":"api/#extractSignalCount","title":"extractSignalCount","text":"<pre><code>func extractSignalCount(c: ScanComplete[MaxThreads]): int</code></pre> <p>Extract the count of signals sent. Terminal operation.</p> Parameters <ul> <li> <code>c</code>               (<code>ScanComplete[MaxThreads]</code>)                            </li> </ul> Returns <p><code>int</code></p> Source:              src/debra/typestates/neutralize.nim:96"},{"location":"api/#epoch-advance","title":"Epoch Advance","text":"<p>Global epoch advancement.</p>"},{"location":"api/#advance","title":"advance","text":"<p>EpochAdvance typestate for advancing the global epoch.</p> <p>Ensures atomic increment of the global epoch counter.</p>"},{"location":"api/#AdvanceContext","title":"AdvanceContext","text":"<pre><code>type AdvanceContext</code></pre> Source:              src/debra/typestates/advance.nim:11"},{"location":"api/#Current","title":"Current","text":"<pre><code>type Current</code></pre> Source:              src/debra/typestates/advance.nim:16"},{"location":"api/#Advancing","title":"Advancing","text":"<pre><code>type Advancing</code></pre> Source:              src/debra/typestates/advance.nim:17"},{"location":"api/#Advanced","title":"Advanced","text":"<pre><code>type Advanced</code></pre> Source:              src/debra/typestates/advance.nim:18"},{"location":"api/#advanceCurrent","title":"advanceCurrent","text":"<pre><code>proc advanceCurrent(mgr: ptr DebraManager[MaxThreads]): Current[MaxThreads]</code></pre> <p>Create epoch advance context.</p> Parameters <ul> <li> <code>mgr</code>               (<code>ptr DebraManager[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Current[MaxThreads]</code></p> Source:              src/debra/typestates/advance.nim:27"},{"location":"api/#advance","title":"advance transition","text":"<pre><code>proc advance(c: sink Current[MaxThreads]): Advancing[MaxThreads]</code></pre> <p>Begin advancing the global epoch.</p> Parameters <ul> <li> <code>c</code>               (<code>sink Current[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Advancing[MaxThreads]</code></p> Source:              src/debra/typestates/advance.nim:35"},{"location":"api/#complete","title":"complete transition","text":"<pre><code>proc complete(a: sink Advancing[MaxThreads]): Advanced[MaxThreads]</code></pre> <p>Complete epoch advance by atomically incrementing globalEpoch.</p> Parameters <ul> <li> <code>a</code>               (<code>sink Advancing[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Advanced[MaxThreads]</code></p> Source:              src/debra/typestates/advance.nim:44"},{"location":"api/#newEpoch","title":"newEpoch","text":"<pre><code>func newEpoch(a: Advanced[MaxThreads]): uint64</code></pre> <p>Get the new epoch value after advancement.</p> Parameters <ul> <li> <code>a</code>               (<code>Advanced[MaxThreads]</code>)                            </li> </ul> Returns <p><code>uint64</code></p> Source:              src/debra/typestates/advance.nim:60"},{"location":"api/#oldEpoch","title":"oldEpoch","text":"<pre><code>func oldEpoch(a: Advanced[MaxThreads]): uint64</code></pre> <p>Get the old epoch value before advancement.</p> Parameters <ul> <li> <code>a</code>               (<code>Advanced[MaxThreads]</code>)                            </li> </ul> Returns <p><code>uint64</code></p> Source:              src/debra/typestates/advance.nim:64"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome! This document outlines how to contribute to nim-debra.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li> <p>Clone the repository: </p><pre><code>git clone https://github.com/elijahr/nim-debra.git\ncd nim-debra\n</code></pre><p></p> </li> <li> <p>Install dependencies: </p><pre><code>nimble install -d\n</code></pre><p></p> </li> <li> <p>Run tests: </p><pre><code>nimble test\n</code></pre><p></p> </li> </ol>"},{"location":"contributing/#testing","title":"Testing","text":"<p>All changes should include tests. The test suite is located in <code>tests/</code>:</p> <ul> <li>Unit tests for individual typestates in <code>tests/t_*.nim</code></li> <li>Integration tests in <code>tests/t_integration.nim</code></li> <li>Main test runner in <code>tests/test.nim</code></li> </ul> <p>Run tests with: </p><pre><code>nimble test\n</code></pre><p></p>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow standard Nim style conventions</li> <li>Use meaningful variable and function names</li> <li>Add documentation comments for public APIs</li> <li>Keep functions focused and single-purpose</li> </ul>"},{"location":"contributing/#typestate-design","title":"Typestate Design","text":"<p>When adding or modifying typestates:</p> <ol> <li>Define states as <code>distinct</code> types wrapping a context object</li> <li>Use <code>typestate</code> block to declare valid transitions</li> <li>Mark transition functions with <code>{.transition.}</code> pragma</li> <li>Write tests that verify both valid and invalid transitions</li> </ol> <p>Example: </p><pre><code>type\n  Context = object\n    data: int\n  StateA = distinct Context\n  StateB = distinct Context\n\ntypestate Context:\n  states StateA, StateB\n  transitions:\n    StateA -&gt; StateB\n\nproc transition(a: StateA): StateB {.transition.} =\n  StateB(a.Context)\n</code></pre><p></p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<ul> <li>Add docstrings to all public procs and types</li> <li>Update relevant guide pages in <code>docs/guide/</code></li> <li>Run <code>mkdocs serve</code> to preview documentation locally</li> </ul>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<ol> <li>Create a feature branch from <code>main</code></li> <li>Make your changes with clear commit messages</li> <li>Add tests for new functionality</li> <li>Update documentation as needed</li> <li>Submit a pull request</li> </ol>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>Open an issue on GitHub or start a discussion.</p>"},{"location":"guide/concepts/","title":"Concepts","text":""},{"location":"guide/concepts/#debra-concepts","title":"DEBRA+ Concepts","text":"<p>Understanding the core concepts behind DEBRA+ memory reclamation.</p>"},{"location":"guide/concepts/#the-memory-reclamation-problem","title":"The Memory Reclamation Problem","text":"<p>In lock-free data structures, traditional memory management approaches fail:</p> <ul> <li>Garbage collection: Adds unpredictable latency and runtime overhead</li> <li>Reference counting: Expensive atomic operations on every access</li> <li>Manual management: Race conditions lead to use-after-free or memory leaks</li> </ul> <p>DEBRA+ provides a middle ground: explicit reclamation with safety guarantees.</p>"},{"location":"guide/concepts/#epoch-based-reclamation","title":"Epoch-Based Reclamation","text":"<p>DEBRA+ uses epochs to track when memory can be safely reclaimed:</p> <ol> <li>Global epoch counter: Monotonically increasing integer</li> <li>Thread epochs: Each active thread pins a specific epoch</li> <li>Retire queues: Objects retired in each epoch</li> <li>Reclamation rule: Objects retired in epoch E are safe to free once all threads have advanced past E</li> </ol>"},{"location":"guide/concepts/#example-timeline","title":"Example Timeline","text":"<pre><code>Time    Global  Thread1  Thread2  Action\n----    ------  -------  -------  ------\nt0      1       -        -        Start\nt1      1       1        -        Thread1 pins epoch 1\nt2      1       1        1        Thread2 pins epoch 1\nt3      2       1        1        Epoch advances to 2\nt4      2       2        1        Thread1 unpins, repins at 2\nt5      2       2        2        Thread2 unpins, repins at 2\nt6      2       2        2        Objects retired at epoch 1 can now be freed\n</code></pre>"},{"location":"guide/concepts/#pinunpin-protocol","title":"Pin/Unpin Protocol","text":"<p>Threads must pin the current epoch before accessing lock-free data structures:</p> <pre><code># WRONG - not protected\nlet value = queue.dequeue()\n\n# RIGHT - pinned during access\nlet pinned = unpinned(handle).pin()\nlet value = queue.dequeue()\ndiscard pinned.unpin()\n</code></pre> <p>Pinning tells the reclamation system: \"I might be accessing objects from this epoch.\"</p>"},{"location":"guide/concepts/#limbo-bags","title":"Limbo Bags","text":"<p>Retired objects are stored in thread-local limbo bags:</p> <ul> <li>Each bag holds up to 64 objects</li> <li>Bags are linked together forming a retire queue</li> <li>Managed objects use <code>GC_unref</code> for cleanup when reclaimed</li> <li>Organized by retirement epoch</li> </ul>"},{"location":"guide/concepts/#limbo-bag-structure","title":"Limbo Bag Structure","text":"<pre><code>Thread State\n  currentBag --&gt; [Bag: epoch=5, count=23] --&gt; [Bag: epoch=4, count=64] --&gt; ...\n                         ^                            ^\n                     limboBagHead                limboBagTail\n</code></pre>"},{"location":"guide/concepts/#safe-reclamation","title":"Safe Reclamation","text":"<p>Reclamation walks the limbo bags and frees objects from old epochs:</p> <ol> <li>Load epochs: Read global epoch and all thread epochs</li> <li>Compute safe epoch: Minimum of all pinned thread epochs</li> <li>Walk limbo bags: From oldest (tail) toward newest (head)</li> <li>Reclaim eligible: Free bags where <code>bag.epoch &lt; safeEpoch - 1</code></li> <li>Stop at barrier: Once we hit a bag that's still unsafe, stop</li> </ol>"},{"location":"guide/concepts/#neutralization","title":"Neutralization","text":"<p>What if a thread stalls while pinned? It blocks reclamation indefinitely.</p> <p>DEBRA+ solves this with neutralization:</p> <ol> <li>Detection: During reclamation, detect threads pinned at old epochs</li> <li>Signal: Send SIGUSR1 to stalled thread's OS process</li> <li>Handler: Signal handler sets neutralization flag</li> <li>Acknowledgment: Thread checks flag on unpin and handles it</li> <li>Recovery: Thread acknowledges, allowing epoch to advance</li> </ol>"},{"location":"guide/concepts/#neutralization-flow","title":"Neutralization Flow","text":"<pre><code># Thread 1: Pinned and working\nlet pinned = unpinned(handle).pin()\n# ... long computation ...\nlet unpinResult = pinned.unpin()\ncase unpinResult.kind:\nof uUnpinned:\n  # Normal unpin\n  discard\nof uNeutralized:\n  # We were neutralized - acknowledge it\n  discard unpinResult.neutralized.acknowledge()\n</code></pre>"},{"location":"guide/concepts/#memory-bounds","title":"Memory Bounds","text":"<p>DEBRA+ guarantees O(mn) memory overhead where:</p> <ul> <li>m = number of threads</li> <li>n = maximum objects retired per epoch per thread</li> </ul> <p>Without neutralization, a stalled thread could accumulate unbounded memory. Neutralization ensures bounded growth.</p>"},{"location":"guide/concepts/#typestate-enforcement","title":"Typestate Enforcement","text":"<p>nim-debra uses compile-time typestates to enforce correct protocol usage:</p> <ul> <li>Cannot retire without being pinned</li> <li>Cannot pin without registering</li> <li>Must acknowledge neutralization before re-pinning</li> </ul> <p>These invariants are checked at compile time, not runtime.</p>"},{"location":"guide/concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about thread registration</li> <li>Understand pin/unpin lifecycle</li> <li>Deep dive into neutralization</li> </ul>"},{"location":"guide/getting-started/","title":"Getting Started","text":""},{"location":"guide/getting-started/#getting-started","title":"Getting Started","text":"<p>This guide walks through setting up and using nim-debra in your lock-free data structures.</p>"},{"location":"guide/getting-started/#installation","title":"Installation","text":"<p>Add nim-debra to your <code>.nimble</code> file:</p> <pre><code>requires \"debra &gt;= 0.1.0\"\n</code></pre> <p>Or install globally:</p> <pre><code>nimble install debra\n</code></pre>"},{"location":"guide/getting-started/#basic-usage","title":"Basic Usage","text":"<p>The following example demonstrates the complete DEBRA+ lifecycle:</p> <ol> <li>Initialize the manager</li> <li>Register the thread</li> <li>Pin/unpin critical sections</li> <li>Retire objects for later reclamation</li> <li>Periodically reclaim memory</li> </ol> <pre><code># examples/basic_usage.nim\n## Basic DEBRA+ usage: initialize manager, register thread, pin/unpin, retire, reclaim.\n\nimport debra\nimport std/atomics\n\n# Node type using ref object pattern for self-reference\ntype\n  NodeObj = object\n    value: int\n    next: Atomic[Managed[ref NodeObj]]\n  Node = ref NodeObj\n\n# Helper to perform one pin/unpin cycle with retirement\nproc doCycle(handle: ThreadHandle[4], manager: var DebraManager[4], value: int) =\n  # Enter critical section\n  let u = unpinned(handle)\n  let pinned = u.pin()\n\n  # Create a managed node (GC won't collect until retired)\n  let node = managed Node(value: value)\n\n  # Retire the node for later reclamation\n  let ready = retireReady(pinned)\n  discard ready.retire(node)\n\n  # Exit critical section\n  let unpinResult = pinned.unpin()\n\n  # Handle neutralization if it occurred\n  case unpinResult.kind:\n  of uUnpinned:\n    discard\n  of uNeutralized:\n    discard unpinResult.neutralized.acknowledge()\n\nproc main() =\n  # 1. Initialize manager (supports up to 4 threads)\n  var manager = initDebraManager[4](../../examples)\n  setGlobalManager(addr manager)\n\n  # 2. Register this thread\n  let handle = registerThread(manager)\n\n  # 3. Simulate some operations\n  for i in 0..&lt;10:\n    doCycle(handle, manager, i)\n\n    # Advance epoch periodically\n    if i mod 3 == 0:\n      manager.advance()\n\n  # 4. Attempt reclamation\n  let reclaimResult = reclaimStart(addr manager)\n    .loadEpochs()\n    .checkSafe()\n\n  case reclaimResult.kind:\n  of rReclaimReady:\n    let count = reclaimResult.reclaimready.tryReclaim()\n    echo \"Reclaimed \", count, \" objects\"\n  of rReclaimBlocked:\n    echo \"Reclamation blocked (normal at startup)\"\n\n  echo \"Basic usage example completed successfully\"\n\nwhen isMainModule:\n  main()\n</code></pre> <p> View full source</p>"},{"location":"guide/getting-started/#key-concepts","title":"Key Concepts","text":"<ul> <li>Manager: Coordinates epoch-based reclamation across threads</li> <li>Handle: Per-thread registration for DEBRA operations</li> <li>Pin/Unpin: Mark critical sections where shared data is accessed</li> <li>Managed[T]: Wrapper type that prevents GC from collecting objects until retired</li> <li>Retire: Mark removed objects for later safe reclamation</li> <li>Reclaim: Free objects when all threads have advanced past their epoch</li> </ul>"},{"location":"guide/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about DEBRA+ concepts</li> <li>Understand thread registration</li> <li>Deep dive into retiring objects</li> </ul>"},{"location":"guide/integration/","title":"Integration","text":""},{"location":"guide/integration/#integration","title":"Integration","text":"<p>Integrating nim-debra with lock-free data structures.</p>"},{"location":"guide/integration/#overview","title":"Overview","text":"<p>This guide shows how to integrate nim-debra into lock-free data structures for safe memory reclamation.</p>"},{"location":"guide/integration/#basic-integration-pattern","title":"Basic Integration Pattern","text":"<ol> <li>Add manager reference to your data structure</li> <li>Register threads on initialization</li> <li>Pin during operations</li> <li>Retire removed nodes</li> <li>Periodically reclaim</li> </ol>"},{"location":"guide/integration/#lock-free-stack","title":"Lock-Free Stack","text":"<p>A complete Treiber stack implementation with DEBRA+ reclamation:</p> <pre><code># examples/lockfree_stack.nim\n## Lock-free Treiber stack with DEBRA reclamation.\n\nimport debra\nimport std/[atomics, options]\n\ntype\n  NodeObj[T] = object\n    value: T\n    next: Atomic[Managed[ref NodeObj[T]]]\n  Node[T] = ref NodeObj[T]\n\n  Stack*[T] = object\n    head: Atomic[Managed[ref NodeObj[T]]]\n    manager: ptr DebraManager[64]\n    handle: ThreadHandle[64]\n\nproc newStack*[T](manager: ptr DebraManager[64]): Stack[T] =\n  result.manager = manager\n  result.handle = registerThread(manager[])\n\nproc push*[T](stack: var Stack[T], value: T) =\n  let pinned = unpinned(stack.handle).pin()\n\n  let newNode = managed Node[T](value: value)\n\n  while true:\n    var oldHead = stack.head.load(moAcquire)\n    newNode.inner.next.store(oldHead, moRelaxed)\n    if stack.head.compareExchange(oldHead, newNode, moRelease, moRelaxed):\n      break\n\n  discard pinned.unpin()\n\nproc pop*[T](stack: var Stack[T]): Option[T] =\n  let pinned = unpinned(stack.handle).pin()\n\n  while true:\n    var oldHead = stack.head.load(moAcquire)\n    if oldHead.isNil:\n      discard pinned.unpin()\n      return none(T)\n\n    let next = oldHead.inner.next.load(moRelaxed)\n    if stack.head.compareExchange(oldHead, next, moRelease, moRelaxed):\n      result = some(oldHead.value)\n\n      # Retire the popped node\n      let ready = retireReady(pinned)\n      discard ready.retire(oldHead)\n\n      discard pinned.unpin()\n      return\n\nproc main() =\n  var manager = initDebraManager[64](../../examples)\n  setGlobalManager(addr manager)\n\n  var stack = newStack[int](../../examples/addr manager)\n\n  echo \"Pushing 1, 2, 3...\"\n  stack.push(1)\n  stack.push(2)\n  stack.push(3)\n\n  echo \"Popping...\"\n  while true:\n    let item = stack.pop()\n    if item.isNone:\n      break\n    echo \"  Popped: \", item.get\n\n  # Reclaim\n  for _ in 0..3:\n    manager.advance()\n\n  let reclaimResult = reclaimStart(addr manager).loadEpochs().checkSafe()\n  case reclaimResult.kind:\n  of rReclaimReady:\n    let count = reclaimResult.reclaimready.tryReclaim()\n    echo \"Reclaimed \", count, \" nodes\"\n  of rReclaimBlocked:\n    echo \"Reclamation blocked\"\n\n  echo \"Lock-free stack example completed\"\n\nwhen isMainModule:\n  main()\n</code></pre> <p> View full source</p>"},{"location":"guide/integration/#lock-free-queue","title":"Lock-Free Queue","text":"<p>A complete Michael-Scott queue implementation with DEBRA+ reclamation:</p> <pre><code># examples/lockfree_queue.nim\n## Lock-free Michael-Scott queue with DEBRA reclamation.\n\nimport debra\nimport std/[atomics, options]\n\ntype\n  NodeObj[T] = object\n    value: T\n    next: Atomic[Managed[ref NodeObj[T]]]\n  Node[T] = ref NodeObj[T]\n\n  Queue*[T] = object\n    head: Atomic[Managed[ref NodeObj[T]]]\n    tail: Atomic[Managed[ref NodeObj[T]]]\n    manager: ptr DebraManager[64]\n    handle: ThreadHandle[64]\n\nproc newQueue*[T](manager: ptr DebraManager[64]): Queue[T] =\n  result.manager = manager\n  result.handle = registerThread(manager[])\n\n  # Create sentinel node\n  let sentinel = managed Node[T](../../examples)\n  result.head.store(sentinel, moRelaxed)\n  result.tail.store(sentinel, moRelaxed)\n\nproc enqueue*[T](queue: var Queue[T], value: T) =\n  let pinned = unpinned(queue.handle).pin()\n\n  let newNode = managed Node[T](value: value)\n\n  while true:\n    var tail = queue.tail.load(moAcquire)\n    let next = tail.inner.next.load(moAcquire)\n\n    if next.isNil:\n      var expected: Managed[Node[T]]\n      if tail.inner.next.compareExchange(expected, newNode, moRelease, moRelaxed):\n        discard queue.tail.compareExchange(tail, newNode, moRelease, moRelaxed)\n        break\n    else:\n      discard queue.tail.compareExchange(tail, next, moRelease, moRelaxed)\n\n  discard pinned.unpin()\n\nproc dequeue*[T](queue: var Queue[T]): Option[T] =\n  let pinned = unpinned(queue.handle).pin()\n\n  while true:\n    var head = queue.head.load(moAcquire)\n    var tail = queue.tail.load(moAcquire)\n    let next = head.inner.next.load(moAcquire)\n\n    if head == tail:\n      if next.isNil:\n        discard pinned.unpin()\n        return none(T)\n      discard queue.tail.compareExchange(tail, next, moRelease, moRelaxed)\n    else:\n      let value = next.value\n      if queue.head.compareExchange(head, next, moRelease, moRelaxed):\n        # Retire old head (sentinel)\n        let ready = retireReady(pinned)\n        discard ready.retire(head)\n\n        discard pinned.unpin()\n        return some(value)\n\nproc main() =\n  var manager = initDebraManager[64](../../examples)\n  setGlobalManager(addr manager)\n\n  var queue = newQueue[int](../../examples/addr manager)\n\n  echo \"Enqueueing 1, 2, 3...\"\n  queue.enqueue(1)\n  queue.enqueue(2)\n  queue.enqueue(3)\n\n  echo \"Dequeueing...\"\n  while true:\n    let item = queue.dequeue()\n    if item.isNone:\n      break\n    echo \"  Dequeued: \", item.get\n\n  # Reclaim\n  for _ in 0..3:\n    manager.advance()\n\n  let reclaimResult = reclaimStart(addr manager).loadEpochs().checkSafe()\n  case reclaimResult.kind:\n  of rReclaimReady:\n    let count = reclaimResult.reclaimready.tryReclaim()\n    echo \"Reclaimed \", count, \" nodes\"\n  of rReclaimBlocked:\n    echo \"Reclamation blocked\"\n\n  echo \"Lock-free queue example completed\"\n\nwhen isMainModule:\n  main()\n</code></pre> <p> View full source</p>"},{"location":"guide/integration/#typestate-composition","title":"Typestate Composition","text":"<p>DEBRA is implemented using nim-typestates. This means you can compose DEBRA's memory safety guarantees with your own application-level typestates.</p> <p>This enables \"correct by design\" algorithms:</p> <ol> <li>Your algorithm's states - Enforced at compile time (e.g., Empty/NonEmpty stack)</li> <li>DEBRA's protocol - Pin/unpin/retire sequence enforced at compile time</li> <li>Bridges - Connect your states to other typestates (e.g., popped items enter a processing pipeline)</li> </ol>"},{"location":"guide/integration/#library-typestates-are-pluggable","title":"Library Typestates Are Pluggable","text":"<p>When you <code>import debra</code>, you get access to DEBRA's typestates:</p> <ul> <li><code>Unpinned[N]</code> / <code>Pinned[N]</code> / <code>Neutralized[N]</code> - Epoch guard states</li> <li><code>RetireReady[N]</code> / <code>Retired[N]</code> - Retirement states</li> <li><code>ReclaimStart[N]</code> / <code>EpochsLoaded[N]</code> / <code>ReclaimReady[N]</code> / <code>ReclaimBlocked[N]</code> - Reclamation states</li> </ul> <p>Your code uses these directly. The compiler verifies you follow the protocol.</p>"},{"location":"guide/integration/#example-item-processing-pipeline","title":"Example: Item Processing Pipeline","text":"<p>Define a typestate for processing items after they leave the data structure:</p> <pre><code># examples/item_processing.nim\n## Item lifecycle typestate for demonstrating typestate composition.\n##\n## This module defines a simple processing pipeline:\n##   Unprocessed -&gt; Processing -&gt; Completed | Failed\n##\n## Use with lockfree_stack_typestates.nim to see how popped items\n## bridge into this processing pipeline.\n\nimport typestates\n\ntype\n  Item*[T] = object\n    ## Base type for items in the processing pipeline.\n    value*: T\n\n  Unprocessed*[T] = distinct Item[T]\n    ## Item just received, not yet being processed.\n\n  Processing*[T] = distinct Item[T]\n    ## Item currently being worked on.\n\n  Completed*[T] = distinct Item[T]\n    ## Item successfully processed (terminal state).\n\n  Failed*[T] = distinct Item[T]\n    ## Item processing failed (terminal state).\n\ntypestate Item[T]:\n  consumeOnTransition = false\n  states Unprocessed[T], Processing[T], Completed[T], Failed[T]\n  initial Unprocessed[T]\n  terminal Completed[T], Failed[T]\n  transitions:\n    Unprocessed[T] -&gt; Processing[T]\n    Processing[T] -&gt; Completed[T] | Failed[T] as ProcessingResult[T]\n\n# Transition: begin processing an item\nproc startProcessing*[T](item: Unprocessed[T]): Processing[T] {.transition.} =\n  ## Begin processing an unprocessed item.\n  Processing[T](../../examples/Item[T](item))\n\n# Transition: finish processing with success or failure\nproc finish*[T](item: Processing[T], success: bool): ProcessingResult[T] {.transition.} =\n  ## Complete processing. Returns Completed on success, Failed otherwise.\n  if success:\n    ProcessingResult[T] -&gt; Completed[T](../../examples/Item[T](item))\n  else:\n    ProcessingResult[T] -&gt; Failed[T](../../examples/Item[T](item))\n\n# Convenience procs for terminal states\nproc complete*[T](item: Processing[T]): Completed[T] {.transition.} =\n  ## Mark item as successfully completed.\n  Completed[T](../../examples/Item[T](item))\n\nproc fail*[T](item: Processing[T]): Failed[T] {.transition.} =\n  ## Mark item as failed.\n  Failed[T](../../examples/Item[T](item))\n\nwhen isMainModule:\n  # Demonstrate the item processing pipeline\n  echo \"Item Processing Typestate Demo\"\n  echo \"==============================\"\n  echo \"\"\n\n  # Create an unprocessed item\n  let raw = Unprocessed[int](../../examples/Item[int](value: 42))\n  echo \"1. Created item in Unprocessed state\"\n\n  # Start processing\n  let inProgress = raw.startProcessing()\n  echo \"2. Transitioned to Processing state\"\n\n  # Finish with success\n  let successResult = inProgress.finish(success = true)\n  echo \"3. Finished processing with success\"\n  case successResult.kind:\n  of pCompleted:\n    echo \"   -&gt; Result: Completed state\"\n  of pFailed:\n    echo \"   -&gt; Result: Failed state (unexpected)\"\n\n  echo \"\"\n\n  # Demo failure path\n  let raw2 = Unprocessed[int](../../examples/Item[int](value: 99))\n  let inProgress2 = raw2.startProcessing()\n  let failResult = inProgress2.finish(success = false)\n  echo \"4. Alternative path: finish with failure\"\n  case failResult.kind:\n  of pCompleted:\n    echo \"   -&gt; Result: Completed state (unexpected)\"\n  of pFailed:\n    echo \"   -&gt; Result: Failed state\"\n\n  echo \"\"\n  echo \"Item processing typestate example completed successfully\"\n</code></pre> <p> View source</p>"},{"location":"guide/integration/#example-stack-with-typestate-composition","title":"Example: Stack with Typestate Composition","text":"<p>Combine stack states, DEBRA states, and bridges to the item processing pipeline:</p> <pre><code># examples/lockfree_stack_typestates.nim\n## Lock-free stack with full typestate composition.\n##\n## Demonstrates:\n## 1. Stack states (Empty, NonEmpty) enforced at compile time\n## 2. DEBRA's pin/unpin/retire typestates used internally\n## 3. Manual bridge from stack to item processing typestate\n##\n## This is a \"correct by design\" lock-free data structure.\n\nimport typestates\nimport debra\nimport ./item_processing\nimport std/[atomics, options]\n\ntype\n  NodeObj[T] = object\n    value: T\n    next: Atomic[Managed[ref NodeObj[T]]]\n  Node[T] = ref NodeObj[T]\n\n  StackBase[T] = object\n    top: Atomic[Managed[ref NodeObj[T]]]\n    manager: ptr DebraManager[64]\n    handle: ThreadHandle[64]\n\n  Empty*[T] = distinct StackBase[T]\n    ## Stack with no elements.\n\n  NonEmpty*[T] = distinct StackBase[T]\n    ## Stack with at least one element.\n\ntypestate StackBase[T]:\n  consumeOnTransition = false\n  states Empty[T], NonEmpty[T]\n  transitions:\n    Empty[T] -&gt; NonEmpty[T]\n    NonEmpty[T] -&gt; Empty[T] | NonEmpty[T] as PopResult[T]\n\nproc initStack*[T](manager: ptr DebraManager[64]): Empty[T] =\n  ## Create a new empty stack.\n  var base: StackBase[T]\n  base.manager = manager\n  base.handle = registerThread(manager[])\n  Empty[T](../../examples/base)\n\nproc push*[T](stack: Empty[T], value: T): NonEmpty[T] {.transition.} =\n  ## Push onto empty stack, returns NonEmpty.\n  var base = StackBase[T](../../examples/stack)\n\n  let pinned = unpinned(base.handle).pin()\n\n  let newNode = managed Node[T](value: value)\n  base.top.store(newNode, moRelease)\n\n  let unpinResult = pinned.unpin()\n  case unpinResult.kind:\n  of uUnpinned: discard\n  of uNeutralized: discard unpinResult.neutralized.acknowledge()\n\n  NonEmpty[T](../../examples/base)\n\nproc push*[T](stack: NonEmpty[T], value: T): NonEmpty[T] {.transition.} =\n  ## Push onto non-empty stack, returns NonEmpty.\n  var base = StackBase[T](../../examples/stack)\n\n  let pinned = unpinned(base.handle).pin()\n\n  let newNode = managed Node[T](value: value)\n\n  while true:\n    var oldTop = base.top.load(moAcquire)\n    newNode.inner.next.store(oldTop, moRelaxed)\n    if base.top.compareExchange(oldTop, newNode, moRelease, moRelaxed):\n      break\n\n  let unpinResult = pinned.unpin()\n  case unpinResult.kind:\n  of uUnpinned: discard\n  of uNeutralized: discard unpinResult.neutralized.acknowledge()\n\n  NonEmpty[T](../../examples/base)\n\nproc pop*[T](stack: NonEmpty[T]): (PopResult[T], Option[Unprocessed[T]]) =\n  ## Pop from non-empty stack.\n  ## Returns (new stack state, optional item in Unprocessed state).\n  var base = StackBase[T](../../examples/stack)\n\n  let pinned = unpinned(base.handle).pin()\n\n  var resultStack: PopResult[T]\n  var item: Option[Unprocessed[T]]\n\n  block popLoop:\n    while true:\n      var oldTop = base.top.load(moAcquire)\n\n      if oldTop.isNil:\n        resultStack = PopResult[T](kind: pEmpty, empty: Empty[T](base))\n        item = none(Unprocessed[T])\n        break popLoop\n\n      let next = oldTop.inner.next.load(moRelaxed)\n\n      if base.top.compareExchange(oldTop, next, moRelease, moRelaxed):\n        item = some(Unprocessed[T](../../examples/Item[T](value: oldTop.value)))\n\n        # Retire the node\n        let ready = retireReady(pinned)\n        discard ready.retire(oldTop)\n\n        if next.isNil:\n          resultStack = PopResult[T](kind: pEmpty, empty: Empty[T](base))\n        else:\n          resultStack = PopResult[T](kind: pNonempty, nonempty: NonEmpty[T](base))\n        break popLoop\n\n  let unpinResult = pinned.unpin()\n  case unpinResult.kind:\n  of uUnpinned: discard\n  of uNeutralized: discard unpinResult.neutralized.acknowledge()\n\n  (resultStack, item)\n\nwhen isMainModule:\n  echo \"Lock-Free Stack with Typestate Composition\"\n  echo \"===========================================\"\n  echo \"\"\n\n  var manager = initDebraManager[64](../../examples)\n  setGlobalManager(addr manager)\n\n  var stack = initStack[int](../../examples/addr manager)\n  echo \"Created empty stack\"\n\n  var nonEmptyStack = stack.push(10)\n  echo \"Pushed 10 (stack is now NonEmpty)\"\n\n  nonEmptyStack = nonEmptyStack.push(20)\n  nonEmptyStack = nonEmptyStack.push(30)\n  echo \"Pushed 20, 30\"\n  echo \"\"\n\n  echo \"Popping and processing items:\"\n  var currentStack = nonEmptyStack\n\n  while true:\n    let (popResult, itemOpt) = currentStack.pop()\n\n    if itemOpt.isSome:\n      let item = itemOpt.get\n      let processing = item.startProcessing()\n      let processResult = processing.finish(success = true)\n\n      case processResult.kind:\n      of pCompleted:\n        echo \"  Popped and completed: \", Item[int](../../examples/processResult.completed).value\n      of pFailed:\n        echo \"  Popped but failed: \", Item[int](../../examples/processResult.failed).value\n    else:\n      echo \"  Race condition: another thread popped the item first\"\n\n    case popResult.kind:\n    of pEmpty:\n      echo \"  Stack is now empty\"\n      break\n    of pNonempty:\n      currentStack = popResult.nonempty\n\n  echo \"\"\n\n  for _ in 0..3:\n    manager.advance()\n\n  let reclaimResult = reclaimStart(addr manager).loadEpochs().checkSafe()\n\n  case reclaimResult.kind:\n  of rReclaimReady:\n    let count = reclaimResult.reclaimready.tryReclaim()\n    echo \"Reclaimed \", count, \" nodes\"\n  of rReclaimBlocked:\n    echo \"Reclamation blocked (threads still active)\"\n\n  echo \"\"\n  echo \"Lock-free stack with typestate composition completed successfully\"\n</code></pre> <p> View source</p>"},{"location":"guide/integration/#key-points","title":"Key Points","text":"<ul> <li>Nested enforcement: DEBRA's <code>pin()</code>/<code>unpin()</code> happens inside your <code>push()</code>/<code>pop()</code> - both are type-checked</li> <li>Bridges connect state machines: Popped items flow from stack states into processing states</li> <li>Zero runtime cost: All validation is compile-time</li> <li>Module-qualified syntax: Use <code>module.Typestate.State</code> in bridges for clarity</li> </ul>"},{"location":"guide/integration/#self-referential-types-pattern","title":"Self-Referential Types Pattern","text":"<p>For types that reference themselves (linked lists, trees), use the <code>ref Obj</code> pattern:</p> <pre><code># The ref Obj pattern for self-referential Managed types\ntype\n  NodeObj[T] = object\n    value: T\n    next: Atomic[Managed[ref NodeObj[T]]]\n  Node[T] = ref NodeObj[T]\n</code></pre> <p>This pattern is required because Nim's type system cannot resolve <code>Managed[Node]</code> inside <code>Node</code>'s definition when <code>Node = ref object</code>.</p>"},{"location":"guide/integration/#best-practices","title":"Best Practices","text":""},{"location":"guide/integration/#1-minimize-critical-section-duration","title":"1. Minimize Critical Section Duration","text":"<pre><code># GOOD - process outside critical section\nlet pinned = handle.pin()\nlet data = loadSharedData()\ndiscard pinned.unpin()\nprocessData(data)\n\n# BAD - process inside critical section\nlet pinned = handle.pin()\nlet data = loadSharedData()\nprocessData(data)\ndiscard pinned.unpin()\n</code></pre>"},{"location":"guide/integration/#2-batch-retirements","title":"2. Batch Retirements","text":"<p>Retire multiple objects in a single critical section when possible.</p>"},{"location":"guide/integration/#3-handle-neutralization","title":"3. Handle Neutralization","text":"<p>Always handle the <code>uNeutralized</code> case from <code>unpin()</code>. This is a required pattern - neutralization occurs when the epoch advances during a critical section, and you must acknowledge it before re-pinning.</p> <pre><code>let unpinResult = pinned.unpin()\ncase unpinResult.kind:\nof uUnpinned:\n  # Normal unpin - continue\n  discard\nof uNeutralized:\n  # Was neutralized - must acknowledge before re-pinning\n  discard unpinResult.neutralized.acknowledge()\n</code></pre>"},{"location":"guide/integration/#4-periodic-reclamation","title":"4. Periodic Reclamation","text":"<p>Don't reclaim after every operation - amortize the cost.</p>"},{"location":"guide/integration/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"guide/integration/#forgetting-to-pin","title":"Forgetting to Pin","text":"<pre><code># WRONG - accessing shared data without pinning\nlet value = queue.head.load(moAcquire).value\n\n# RIGHT - pin before access\nlet pinned = handle.pin()\nlet value = queue.head.load(moAcquire).value\ndiscard pinned.unpin()\n</code></pre>"},{"location":"guide/integration/#retiring-too-early","title":"Retiring Too Early","text":"<pre><code># WRONG - retire before unlinking\ndiscard ready.retire(oldHead)\nqueue.head.store(newHead, moRelease)\n\n# RIGHT - retire after unlinking\nqueue.head.store(newHead, moRelease)\ndiscard ready.retire(oldHead)\n</code></pre>"},{"location":"guide/integration/#sharing-handles","title":"Sharing Handles","text":"<pre><code># WRONG - sharing handle between threads\nvar sharedHandle: ThreadHandle[64]\n\n# RIGHT - each thread has own handle\nproc workerThread() {.thread.} =\n  let handle = registerThread(manager)\n</code></pre>"},{"location":"guide/integration/#performance-tips","title":"Performance Tips","text":"<ol> <li>Batch operations: Pin once for multiple operations</li> <li>Amortize reclamation: Reclaim every N operations</li> <li>Dedicated reclaimer: Use background thread for reclamation</li> <li>Minimize pinning: Only pin when accessing shared data</li> <li>Avoid blocking: Don't block while pinned</li> </ol>"},{"location":"guide/integration/#next-steps","title":"Next Steps","text":"<ul> <li>Review API reference</li> <li>Study the complete examples in the repository</li> <li>Benchmark your integration</li> </ul>"},{"location":"guide/neutralization/","title":"Neutralization","text":""},{"location":"guide/neutralization/#neutralization","title":"Neutralization","text":"<p>Understanding the signal-based neutralization protocol.</p>"},{"location":"guide/neutralization/#state-machine","title":"State Machine","text":""},{"location":"guide/neutralization/#overview","title":"Overview","text":"<p>Neutralization solves the stalled thread problem: what happens when a thread stays pinned for a long time? Without intervention, it blocks reclamation and memory accumulates unboundedly.</p> <p>DEBRA+ uses POSIX signals to neutralize stalled threads, allowing epoch advancement and bounded memory.</p>"},{"location":"guide/neutralization/#the-stalled-thread-problem","title":"The Stalled Thread Problem","text":"<p>If a thread stays pinned at an old epoch:</p> <ul> <li>Reclamation is blocked indefinitely</li> <li>Memory accumulates in limbo bags</li> <li>System may run out of memory</li> </ul>"},{"location":"guide/neutralization/#how-neutralization-works","title":"How Neutralization Works","text":"<ol> <li>Detection: Reclamation detects thread pinned at old epoch</li> <li>Signal: Send SIGUSR1 to stalled thread</li> <li>Handler: Signal handler sets neutralization flag</li> <li>Check: Thread checks flag when it unpins</li> <li>Acknowledge: Thread acknowledges neutralization</li> <li>Advance: Safe epoch can now advance past stalled thread</li> </ol>"},{"location":"guide/neutralization/#triggering-neutralization","title":"Triggering Neutralization","text":"<p>The simple convenience API allows scanning for and signaling stalled threads:</p> <pre><code>let signalsSent = neutralizeStalled(manager)\n</code></pre> <p>This returns the number of signals sent to stalled threads.</p> <p>The <code>epochsBeforeNeutralize</code> parameter controls how far behind a thread must be before neutralization (default is 2 epochs):</p> <pre><code>let signalsSent = neutralizeStalled(manager, epochsBeforeNeutralize = 3)\n</code></pre> <p>For advanced use cases, the low-level typestate API provides explicit control over each step:</p> <pre><code>let complete = scanStart(addr manager)\n  .loadEpoch(epochsBeforeNeutralize = 2)\n  .scanAndSignal()\nlet count = complete.extractSignalCount()\n</code></pre>"},{"location":"guide/neutralization/#neutralization-handling-example","title":"Neutralization Handling Example","text":"<pre><code># examples/neutralization_handling.nim\n## Neutralization: handling signal-based interruption of stalled threads.\n\nimport debra\nimport std/atomics\n\nwhen isMainModule:\n  var manager = initDebraManager[4](../../examples)\n  setGlobalManager(addr manager)\n\n  let handle = registerThread(manager)\n\n  # Wrapper that handles neutralization automatically\n  proc withPinnedSection(body: proc()) =\n    let u = unpinned(handle)\n    let pinned = u.pin()\n\n    body()\n\n    let unpinResult = pinned.unpin()\n    case unpinResult.kind:\n    of uUnpinned:\n      discard\n    of uNeutralized:\n      # Acknowledge and the caller can retry if needed\n      discard unpinResult.neutralized.acknowledge()\n\n  # Use the wrapper for clean critical sections\n  withPinnedSection(proc() =\n    echo \"Working in critical section...\"\n  )\n\n  # Manual handling with retry logic\n  block manualRetry:\n    var attempts = 0\n    var done = false\n\n    while not done and attempts &lt; 3:\n      inc attempts\n      let u = unpinned(handle)\n      let pinned = u.pin()\n\n      # Simulate work\n      echo \"Attempt \", attempts\n\n      # Simulate neutralization on first attempt\n      if attempts == 1:\n        manager.threads[handle.idx].neutralized.store(true, moRelease)\n\n      let unpinResult = pinned.unpin()\n      case unpinResult.kind:\n      of uUnpinned:\n        done = true\n        echo \"Completed on attempt \", attempts\n      of uNeutralized:\n        echo \"Neutralized on attempt \", attempts, \" - will retry\"\n        discard unpinResult.neutralized.acknowledge()\n\n  echo \"Neutralization handling example completed successfully\"\n</code></pre> <p> View full source</p>"},{"location":"guide/neutralization/#neutralization-semantics","title":"Neutralization Semantics","text":"<p>Neutralization is advisory, not forceful:</p> <ul> <li>Thread is not stopped mid-computation</li> <li>Thread is not killed or interrupted</li> <li>Thread continues running normally</li> <li>Flag is checked on next unpin</li> </ul>"},{"location":"guide/neutralization/#safety-guarantees","title":"Safety Guarantees","text":"<ul> <li>Neutralization cannot corrupt memory</li> <li>Thread completes current operation safely</li> <li>Lock-free operations remain atomic</li> <li>Memory ordering is preserved</li> </ul>"},{"location":"guide/neutralization/#limitations","title":"Limitations","text":"<p>Neutralization cannot:</p> <ul> <li>Stop a thread in an infinite loop</li> <li>Interrupt blocking system calls</li> <li>Force a thread to check the flag</li> <li>Guarantee timely response</li> </ul>"},{"location":"guide/neutralization/#configuration","title":"Configuration","text":""},{"location":"guide/neutralization/#neutralization-threshold","title":"Neutralization Threshold","text":"<p>How far behind before neutralizing? Default is 2 epochs.</p> <p>Lower threshold = more aggressive neutralization, better memory bounds, more interruptions.</p> <p>Higher threshold = more lenient on long operations, higher memory usage, fewer interruptions.</p>"},{"location":"guide/neutralization/#signal-choice","title":"Signal Choice","text":"<p>DEBRA+ uses SIGUSR1 by default. Requirements:</p> <ul> <li>Must not be used by application</li> <li>Must not have default handler</li> <li>Must be available on platform</li> </ul>"},{"location":"guide/neutralization/#platform-considerations","title":"Platform Considerations","text":"<p>Neutralization works on POSIX systems (Linux, macOS, BSD). Windows does not support pthread_kill and would require alternative approaches.</p>"},{"location":"guide/neutralization/#best-practices","title":"Best Practices","text":""},{"location":"guide/neutralization/#keep-critical-sections-short","title":"Keep Critical Sections Short","text":"<p>Avoid neutralization by keeping pin/unpin sections minimal:</p> <pre><code># GOOD - short critical section\nlet pinned = handle.pin()\nlet node = queue.dequeue()\ndiscard pinned.unpin()\nprocessNode(node)  # Outside critical section\n\n# BAD - long critical section\nlet pinned = handle.pin()\nlet node = queue.dequeue()\nprocessNode(node)  # Inside critical section!\ndiscard pinned.unpin()\n</code></pre>"},{"location":"guide/neutralization/#handle-neutralization-gracefully","title":"Handle Neutralization Gracefully","text":"<p>Don't treat neutralization as an error - retry the operation.</p>"},{"location":"guide/neutralization/#monitor-neutralization-rate","title":"Monitor Neutralization Rate","text":"<p>Frequent neutralization indicates:</p> <ul> <li>Critical sections are too long</li> <li>Operations are blocking</li> <li>Threshold is too aggressive</li> </ul>"},{"location":"guide/neutralization/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about integration patterns</li> <li>Review API reference</li> </ul>"},{"location":"guide/pin-unpin/","title":"Pin/Unpin","text":""},{"location":"guide/pin-unpin/#pinunpin-protocol","title":"Pin/Unpin Protocol","text":"<p>Understanding the pin/unpin lifecycle for critical sections.</p>"},{"location":"guide/pin-unpin/#state-machine","title":"State Machine","text":""},{"location":"guide/pin-unpin/#overview","title":"Overview","text":"<p>The pin/unpin protocol marks critical sections where threads access lock-free data structures. Pinning prevents reclamation of objects from the current epoch.</p>"},{"location":"guide/pin-unpin/#pin-operation","title":"Pin Operation","text":"<p>When you call <code>pin()</code>:</p> <ol> <li>Load global epoch: Read the current global epoch counter</li> <li>Clear neutralization: Reset the neutralization flag</li> <li>Store epoch: Write epoch to thread's epoch slot</li> <li>Set pinned flag: Mark thread as pinned</li> </ol>"},{"location":"guide/pin-unpin/#unpin-operation","title":"Unpin Operation","text":"<p>When you call <code>unpin()</code>:</p> <ol> <li>Clear pinned flag: Mark thread as no longer pinned</li> <li>Check neutralization: Read the neutralization flag</li> <li>Return result: Either <code>Unpinned</code> or <code>Neutralized</code> state</li> </ol>"},{"location":"guide/pin-unpin/#critical-section-example","title":"Critical Section Example","text":"<p>The following example demonstrates pin/unpin patterns and neutralization handling:</p> <pre><code># examples/pin_unpin.nim\n## Pin/unpin lifecycle example with neutralization handling.\n\nimport debra\nimport std/atomics\n\ntype\n  NodeObj = object\n    value: int\n    next: Atomic[Managed[ref NodeObj]]\n  Node = ref NodeObj\n\nproc main() =\n  var manager = initDebraManager[4](../../examples)\n  setGlobalManager(addr manager)\n  let handle = registerThread(manager)\n\n  # Basic pin/unpin cycle\n  echo \"=== Basic Pin/Unpin ===\"\n  block:\n    let pinned = unpinned(handle).pin()\n    echo \"Thread pinned at epoch: \", pinned.epoch\n\n    # Do work while pinned...\n    let node = managed Node(value: 42)\n    echo \"Created node: \", node.value\n\n    let unpinResult = pinned.unpin()\n    case unpinResult.kind:\n    of uUnpinned:\n      echo \"Normal unpin\"\n    of uNeutralized:\n      echo \"Was neutralized - acknowledging\"\n      discard unpinResult.neutralized.acknowledge()\n\n  # Multiple pin/unpin cycles\n  echo \"\"\n  echo \"=== Multiple Cycles ===\"\n  for i in 1..3:\n    let pinned = unpinned(handle).pin()\n    echo \"Cycle \", i, \": pinned at epoch \", pinned.epoch\n\n    # Retire a node\n    let node = managed Node(value: i * 100)\n    let ready = retireReady(pinned)\n    discard ready.retire(node)\n\n    let unpinResult = pinned.unpin()\n    case unpinResult.kind:\n    of uUnpinned:\n      echo \"Cycle \", i, \": unpinned normally\"\n    of uNeutralized:\n      echo \"Cycle \", i, \": neutralized\"\n      discard unpinResult.neutralized.acknowledge()\n\n    # Advance epoch between cycles\n    manager.advance()\n\n  echo \"\"\n  echo \"Pin/unpin example completed\"\n\nwhen isMainModule:\n  main()\n</code></pre> <p> View full source</p>"},{"location":"guide/pin-unpin/#what-you-can-do-while-pinned","title":"What You Can Do While Pinned","text":"<ul> <li>Read shared memory from lock-free structures</li> <li>Perform CAS operations to modify shared state</li> <li>Retire objects that have been removed</li> <li>Access multiple structures in same critical section</li> </ul>"},{"location":"guide/pin-unpin/#what-you-cannot-do-while-pinned","title":"What You Cannot Do While Pinned","text":"<p>Avoid these while pinned:</p> <ul> <li>Blocking operations: Don't hold locks, wait on condition variables</li> <li>Long computations: Keep critical sections short</li> <li>I/O operations: Don't do file/network I/O while pinned</li> <li>Sleeping: Don't call sleep or delay functions</li> </ul> <p>Why? While a thread is pinned, objects retired by other threads cannot be reclaimed. Long critical sections delay reclamation and cause memory to accumulate in limbo bags.</p>"},{"location":"guide/pin-unpin/#typestate-guarantees","title":"Typestate Guarantees","text":"<p>The typestate system enforces:</p> <ol> <li>Cannot retire unpinned: Must be in <code>Pinned</code> state to retire objects</li> <li>Cannot double-pin: Once pinned, cannot pin again without unpinning</li> <li>Must acknowledge neutralization: Cannot pin after neutralization without acknowledging</li> </ol> <p>These are compile-time guarantees - if it compiles, the protocol is correct.</p>"},{"location":"guide/pin-unpin/#performance-considerations","title":"Performance Considerations","text":"<p>Pin/unpin overhead:</p> <ul> <li>Pin: ~10-20ns (1 atomic load, 1 atomic store, 2 relaxed stores)</li> <li>Unpin: ~5-10ns (1 relaxed store, 1 atomic load)</li> </ul> <p>This is negligible compared to lock-free operation costs.</p>"},{"location":"guide/pin-unpin/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about retiring objects</li> <li>Understand neutralization</li> <li>See integration examples</li> </ul>"},{"location":"guide/reclamation/","title":"Reclamation","text":""},{"location":"guide/reclamation/#reclamation","title":"Reclamation","text":"<p>Understanding safe memory reclamation in DEBRA+.</p>"},{"location":"guide/reclamation/#state-machine","title":"State Machine","text":""},{"location":"guide/reclamation/#overview","title":"Overview","text":"<p>Reclamation is the process of safely freeing retired objects. The reclamation system walks thread-local limbo bags and frees objects from old epochs that are no longer accessible.</p>"},{"location":"guide/reclamation/#reclamation-steps","title":"Reclamation Steps","text":"<ol> <li>Start: Begin reclamation process</li> <li>Load epochs: Read global epoch and all thread epochs</li> <li>Check safety: Determine if any epochs are safe to reclaim</li> <li>Try reclaim: Walk limbo bags and free eligible objects</li> </ol>"},{"location":"guide/reclamation/#epoch-safety","title":"Epoch Safety","text":"<p>The safe epoch is the minimum of all pinned thread epochs. Objects retired in epoch E are safe to reclaim if <code>E &lt; safeEpoch - 1</code>.</p>"},{"location":"guide/reclamation/#periodic-reclamation","title":"Periodic Reclamation","text":"<p>Attempt reclamation every N operations to amortize the cost:</p> <pre><code># examples/reclamation_periodic.nim\n## Periodic reclamation: attempt reclamation every N operations.\n\nimport debra\nimport std/atomics\n\ntype\n  NodeObj = object\n    value: int\n  Node = ref NodeObj\n\nconst ReclaimInterval = 10\n\nproc doOperation(handle: ThreadHandle[64], i: int) =\n  let u = unpinned(handle)\n  let pinned = u.pin()\n\n  let node = managed Node(value: i)\n  let ready = retireReady(pinned)\n  discard ready.retire(node)\n\n  let unpinResult = pinned.unpin()\n  case unpinResult.kind:\n  of uUnpinned: discard\n  of uNeutralized: discard unpinResult.neutralized.acknowledge()\n\nproc periodicReclaimDemo() =\n  var manager = initDebraManager[64](../../examples)\n  setGlobalManager(addr manager)\n\n  let handle = registerThread(manager)\n  var totalReclaimed = 0\n\n  # Perform operations with periodic reclamation\n  for i in 0..&lt;50:\n    # Do one operation\n    doOperation(handle, i)\n\n    # Advance epoch periodically\n    if i mod 5 == 0:\n      manager.advance()\n\n    # Attempt reclamation every ReclaimInterval operations\n    if i mod ReclaimInterval == ReclaimInterval - 1:\n      let reclaimResult = reclaimStart(addr manager)\n        .loadEpochs()\n        .checkSafe()\n\n      case reclaimResult.kind:\n      of rReclaimReady:\n        let count = reclaimResult.reclaimready.tryReclaim()\n        totalReclaimed += count\n        echo \"Operation \", i, \": reclaimed \", count, \" objects\"\n      of rReclaimBlocked:\n        echo \"Operation \", i, \": reclamation blocked\"\n\n  echo \"Total reclaimed: \", totalReclaimed, \" objects\"\n  echo \"Periodic reclamation example completed successfully\"\n\nwhen isMainModule:\n  periodicReclaimDemo()\n</code></pre> <p> View full source</p>"},{"location":"guide/reclamation/#background-reclamation","title":"Background Reclamation","text":"<p>Dedicate a thread to reclamation for best separation of concerns:</p> <pre><code># examples/reclamation_background.nim\n## Background reclamation: dedicated thread for memory reclamation.\n\nimport debra\nimport std/[atomics, os]\n\ntype\n  NodeObj = object\n    value: int\n  Node = ref NodeObj\n\nvar\n  manager: DebraManager[4]\n  shouldStop: Atomic[bool]\n  totalReclaimed: Atomic[int]\n\nproc reclaimerThread() {.thread.} =\n  ## Background thread that periodically attempts reclamation.\n  while not shouldStop.load(moAcquire):\n    let reclaimResult = reclaimStart(addr manager)\n      .loadEpochs()\n      .checkSafe()\n\n    case reclaimResult.kind:\n    of rReclaimReady:\n      {.cast(gcsafe).}:\n        let count = reclaimResult.reclaimready.tryReclaim()\n        discard totalReclaimed.fetchAdd(count, moRelaxed)\n    of rReclaimBlocked:\n      discard\n\n    sleep(5)  # 5ms between attempts\n\nproc workerThread() {.thread.} =\n  ## Worker thread that performs operations.\n  let handle = registerThread(manager)\n\n  for i in 0..&lt;100:\n    let u = unpinned(handle)\n    let pinned = u.pin()\n\n    let node = managed Node(value: i)\n    let ready = retireReady(pinned)\n    discard ready.retire(node)\n\n    let unpinResult = pinned.unpin()\n    case unpinResult.kind:\n    of uUnpinned: discard\n    of uNeutralized: discard unpinResult.neutralized.acknowledge()\n\n    # Occasionally advance epoch\n    if i mod 10 == 0:\n      manager.advance()\n\nwhen isMainModule:\n  manager = initDebraManager[4](../../examples)\n  setGlobalManager(addr manager)\n  shouldStop.store(false, moRelaxed)\n  totalReclaimed.store(0, moRelaxed)\n\n  # Start background reclaimer\n  var reclaimer: Thread[void]\n  createThread(reclaimer, reclaimerThread)\n\n  # Start worker threads\n  var workers: array[2, Thread[void]]\n  for i in 0..&lt;2:\n    createThread(workers[i], workerThread)\n\n  # Wait for workers to finish\n  for i in 0..&lt;2:\n    joinThread(workers[i])\n\n  # Give reclaimer time to clean up remaining objects\n  sleep(50)\n\n  # Stop reclaimer\n  shouldStop.store(true, moRelease)\n  joinThread(reclaimer)\n\n  echo \"Total reclaimed by background thread: \", totalReclaimed.load(moRelaxed)\n  echo \"Background reclamation example completed successfully\"\n</code></pre> <p> View full source</p>"},{"location":"guide/reclamation/#blocked-reclamation","title":"Blocked Reclamation","text":"<p>If <code>safeEpoch &lt;= 1</code>, reclamation is blocked. This is normal when:</p> <ul> <li>All threads pinned at current epoch</li> <li>Only one epoch has passed since start</li> </ul> <p>Options when blocked:</p> <ol> <li>Advance epoch: Trigger epoch advancement</li> <li>Wait: Try again later</li> <li>Neutralize: If a thread is stalled, neutralize it</li> </ol>"},{"location":"guide/reclamation/#reclamation-scheduling","title":"Reclamation Scheduling","text":"<p>Too frequent: - Wastes CPU checking epochs - Most checks find nothing to reclaim</p> <p>Too infrequent: - Accumulates memory - Longer pause when reclaim happens</p> <p>Recommended: Every 100-1000 operations or every 10-100ms.</p>"},{"location":"guide/reclamation/#performance-considerations","title":"Performance Considerations","text":"<p>Reclamation cost:</p> <ul> <li>Load epochs: O(m) where m = max threads</li> <li>Walk bags: O(n) where n = retired objects</li> <li>Total: O(m + n)</li> </ul> <p>Optimization tips:</p> <ol> <li>Batch reclamation: Don't reclaim after every operation</li> <li>Separate thread: Dedicate a thread to reclamation</li> <li>Threshold: Only reclaim when enough objects accumulated</li> </ol>"},{"location":"guide/reclamation/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about neutralization</li> <li>Understand integration patterns</li> </ul>"},{"location":"guide/retiring-objects/","title":"Retiring Objects","text":""},{"location":"guide/retiring-objects/#retiring-objects","title":"Retiring Objects","text":"<p>Understanding how to retire objects for safe reclamation.</p>"},{"location":"guide/retiring-objects/#state-machine","title":"State Machine","text":""},{"location":"guide/retiring-objects/#overview","title":"Overview","text":"<p>When you remove an object from a lock-free data structure, you cannot immediately free it - other threads might still be accessing it. Instead, you retire the object, marking it for later reclamation when safe.</p>"},{"location":"guide/retiring-objects/#the-managed-type","title":"The Managed Type","text":"<p>DEBRA uses the <code>Managed[T]</code> wrapper type to track objects that need epoch-based reclamation:</p> <pre><code>type\n  NodeObj = object\n    value: int\n    next: Atomic[Managed[ref NodeObj]]\n  Node = ref NodeObj\n\n# Create a managed node - GC won't collect until retired\nlet node = managed Node(value: 42)\n</code></pre> <p>The <code>managed()</code> proc calls <code>GC_ref</code> internally, preventing Nim's garbage collector from freeing the object. Only DEBRA's reclamation process (via <code>GC_unref</code>) can free it.</p>"},{"location":"guide/retiring-objects/#self-referential-types","title":"Self-Referential Types","text":"<p>When a type references itself (like linked list nodes), use the <code>ref Obj</code> pattern:</p> <pre><code># CORRECT - use ref Obj pattern for self-reference\ntype\n  NodeObj = object\n    value: int\n    next: Atomic[Managed[ref NodeObj]]  # Self-reference works\n  Node = ref NodeObj\n\n# INCORRECT - ref object inline won't work\ntype\n  Node = ref object\n    value: int\n    next: Atomic[Managed[Node]]  # Won't compile\n</code></pre> <p>This is a Nim limitation with generic distinct types and forward references.</p>"},{"location":"guide/retiring-objects/#basic-retirement","title":"Basic Retirement","text":"<p>You must be pinned to retire objects:</p> <pre><code># examples/retire_single.nim\n## Single object retirement example.\n\nimport debra\nimport std/atomics\n\ntype\n  NodeObj = object\n    value: int\n    next: Atomic[Managed[ref NodeObj]]\n  Node = ref NodeObj\n\nproc main() =\n  var manager = initDebraManager[4](../../examples)\n  setGlobalManager(addr manager)\n  let handle = registerThread(manager)\n\n  # Enter critical section\n  let pinned = unpinned(handle).pin()\n\n  # Create a managed node\n  let node = managed Node(value: 42)\n  echo \"Created node with value: \", node.value\n\n  # Retire the node\n  let ready = retireReady(pinned)\n  discard ready.retire(node)\n  echo \"Node retired for later reclamation\"\n\n  # Exit critical section\n  discard pinned.unpin()\n\n  echo \"Single retirement example completed\"\n\nwhen isMainModule:\n  main()\n</code></pre> <p> View full source</p>"},{"location":"guide/retiring-objects/#multiple-object-retirement","title":"Multiple Object Retirement","text":"<p>When retiring multiple objects in a single critical section, use <code>retireReadyFromRetired()</code> to chain retirements:</p> <pre><code># examples/retire_multiple.nim\n## Multiple object retirement example.\n\nimport debra\nimport std/atomics\n\ntype\n  NodeObj = object\n    value: int\n    next: Atomic[Managed[ref NodeObj]]\n  Node = ref NodeObj\n\nproc main() =\n  var manager = initDebraManager[4](../../examples)\n  setGlobalManager(addr manager)\n  let handle = registerThread(manager)\n\n  # Enter critical section\n  let pinned = unpinned(handle).pin()\n\n  # Retire multiple nodes in a single critical section\n  var ready = retireReady(pinned)\n\n  for i in 1..5:\n    let node = managed Node(value: i * 10)\n    echo \"Retiring node with value: \", node.value\n    let retired = ready.retire(node)\n    ready = retireReadyFromRetired(retired)\n\n  echo \"Retired 5 nodes\"\n\n  # Exit critical section\n  discard pinned.unpin()\n\n  echo \"Multiple retirement example completed\"\n\nwhen isMainModule:\n  main()\n</code></pre> <p> View full source</p>"},{"location":"guide/retiring-objects/#accessing-managed-fields","title":"Accessing Managed Fields","text":"<p>The <code>Managed[T]</code> type provides transparent field access:</p> <pre><code>let node = managed Node(value: 42, name: \"test\")\n\n# Direct field access via dot template\necho node.value  # 42\necho node.name   # \"test\"\n\n# When you need the actual ref\ndoSomething(node.inner)\n</code></pre>"},{"location":"guide/retiring-objects/#limbo-bags","title":"Limbo Bags","text":"<p>Retired objects are stored in thread-local limbo bags:</p> <ul> <li>Each bag holds up to 64 objects</li> <li>Bags are chained together by epoch</li> <li>Reclamation walks bags from oldest to newest</li> </ul>"},{"location":"guide/retiring-objects/#retirement-timing","title":"Retirement Timing","text":"<p>Always unlink first, then retire:</p> <pre><code># RIGHT - retire after unlinking\nif head.compareExchange(oldHead, next, moRelease, moRelaxed):\n  let ready = retireReady(pinned)\n  discard ready.retire(oldHead)\n\n# WRONG - retire before unlinking (unsafe!)\nlet ready = retireReady(pinned)\ndiscard ready.retire(oldHead)\nhead.store(next, moRelease)\n</code></pre>"},{"location":"guide/retiring-objects/#best-practices","title":"Best Practices","text":""},{"location":"guide/retiring-objects/#do-retire-objects-that","title":"Do Retire Objects That:","text":"<ul> <li>Were removed from shared data structures</li> <li>Are no longer reachable via shared pointers</li> <li>Might still be accessed by concurrent threads</li> </ul>"},{"location":"guide/retiring-objects/#dont-retire-objects-that","title":"Don't Retire Objects That:","text":"<ul> <li>Are still reachable in the data structure</li> <li>Are local to the current thread (just let them go out of scope)</li> <li>Are static/global (they're never freed)</li> </ul>"},{"location":"guide/retiring-objects/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about reclamation</li> <li>Understand neutralization</li> <li>See integration examples</li> </ul>"},{"location":"guide/thread-registration/","title":"Thread Registration","text":""},{"location":"guide/thread-registration/#thread-registration","title":"Thread Registration","text":"<p>Understanding thread registration lifecycle in DEBRA+.</p>"},{"location":"guide/thread-registration/#state-machine","title":"State Machine","text":""},{"location":"guide/thread-registration/#overview","title":"Overview","text":"<p>Each thread must register with the DEBRA manager before performing pin/unpin operations. Registration allocates a thread slot and provides a handle for all subsequent operations.</p>"},{"location":"guide/thread-registration/#registration-process","title":"Registration Process","text":"<p>Registration performs several steps:</p> <ol> <li>Search for an unused slot in the thread array</li> <li>Claim the slot by setting the thread ID</li> <li>Initialize the slot's epoch and flags</li> <li>Return a handle containing the slot index</li> </ol>"},{"location":"guide/thread-registration/#thread-limits","title":"Thread Limits","text":"<p>The manager is created with a compile-time maximum thread count:</p> <pre><code>var manager = initDebraManager[64]()  # Support up to 64 threads\n</code></pre> <p>Attempting to register more threads than the limit will raise <code>DebraRegistrationError</code>.</p>"},{"location":"guide/thread-registration/#multi-thread-example","title":"Multi-Thread Example","text":"<p>The following example demonstrates multiple threads registering and using DEBRA:</p> <pre><code># examples/thread_registration.nim\n## Thread registration lifecycle: multiple threads registering and using DEBRA.\n\nimport debra\nimport std/atomics\n\nvar manager: DebraManager[4]\n\nproc workerThread() {.thread.} =\n  # Register this thread with the manager\n  let handle = registerThread(manager)\n\n  # Perform some pin/unpin cycles\n  for i in 0..&lt;100:\n    let u = unpinned(handle)\n    let pinned = u.pin()\n\n    # Simulate work in critical section\n    discard\n\n    let unpinResult = pinned.unpin()\n    case unpinResult.kind:\n    of uUnpinned:\n      discard\n    of uNeutralized:\n      discard unpinResult.neutralized.acknowledge()\n\nwhen isMainModule:\n  # Initialize manager\n  manager = initDebraManager[4](../../examples)\n  setGlobalManager(addr manager)\n\n  # Start worker threads\n  var threads: array[4, Thread[void]]\n  for i in 0..&lt;4:\n    createThread(threads[i], workerThread)\n\n  # Wait for all threads to complete\n  for i in 0..&lt;4:\n    joinThread(threads[i])\n\n  echo \"Thread registration example completed successfully\"\n</code></pre> <p> View full source</p>"},{"location":"guide/thread-registration/#per-thread-state","title":"Per-Thread State","text":"<p>Each thread slot maintains:</p> <ul> <li>epoch: Current/pinned epoch</li> <li>pinned: Is thread in critical section?</li> <li>neutralized: Neutralization flag</li> <li>threadId: Thread identifier for signaling</li> <li>limboBags: Chain of retired objects</li> </ul>"},{"location":"guide/thread-registration/#best-practices","title":"Best Practices","text":"<ol> <li>Register once per thread: Don't register multiple times</li> <li>Keep handle alive: Store the handle for the thread's lifetime</li> <li>Don't share handles: Each thread needs its own handle</li> <li>Respect limits: Don't exceed MaxThreads parameter</li> </ol>"},{"location":"guide/thread-registration/#current-limitations","title":"Current Limitations","text":""},{"location":"guide/thread-registration/#thread-slot-lifetime","title":"Thread Slot Lifetime","text":"<p>Thread slots are held for the thread's lifetime. Once a thread registers, its slot remains occupied until the manager is destroyed. There is currently no explicit deregistration API.</p> <p>If a thread exits after registration, its slot remains allocated and cannot be reused until the entire manager shuts down. This means the effective thread limit is determined by the peak number of threads that register over the manager's lifetime, not the number of concurrent threads.</p> <p>Implication: Plan your <code>MaxThreads</code> parameter based on the total number of threads that will register throughout your application's lifetime, not just the concurrent thread count.</p>"},{"location":"guide/thread-registration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/thread-registration/#maximum-threads-already-registered","title":"\"Maximum threads already registered\"","text":"<p>All slots are occupied. Either:</p> <ul> <li>Increase <code>MaxThreads</code> when creating the manager</li> <li>Reduce the total number of threads that register over the application lifetime</li> <li>Check for thread leaks or unnecessary thread creation</li> </ul>"},{"location":"guide/thread-registration/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about pin/unpin lifecycle</li> <li>Understand retiring objects</li> </ul>"}]}