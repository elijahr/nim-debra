{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#nim-debra","title":"nim-debra","text":"<p>DEBRA+ safe memory reclamation for lock-free data structures in Nim.</p>"},{"location":"#what-is-this","title":"What is this?","text":"<p>nim-debra implements the DEBRA+ algorithm (Distributed Epoch-Based Reclamation with Neutralization) for safe memory reclamation in lock-free concurrent data structures. It provides a compile-time typestate-enforced API that ensures correct usage of the reclamation protocol.</p> <pre><code>import debra\n\n# Initialize manager (one per process)\nvar manager = initDebraManager[64]()\nsetGlobalManager(addr manager)\n\n# Register thread (once per thread)\nlet handle = registerThread(manager)\n\n# Critical section - pin to protect memory access\nlet pinned = handle.pin()\n# ... safely access lock-free data structures ...\ndiscard pinned.unpin()\n\n# Retire objects when they're no longer needed\nlet retired = retireObject(pinned, ptr, destructor)\n</code></pre> <p>The typestate system ensures you cannot accidentally access memory outside a critical section, retire objects without being pinned, or perform operations in the wrong order. If it compiles, the protocol is correct.</p>"},{"location":"#what-is-debra","title":"What is DEBRA+?","text":"<p>DEBRA+ is an epoch-based memory reclamation algorithm designed for lock-free data structures. Traditional garbage collection adds runtime overhead and unpredictable pauses. Manual memory management in concurrent code leads to use-after-free bugs and memory leaks.</p> <p>DEBRA+ solves this by:</p> <ul> <li>Epoch-based tracking: Global epoch counter advances as threads complete operations</li> <li>Pin/unpin protocol: Threads pin the current epoch while accessing shared data</li> <li>Safe reclamation: Objects retired in epoch E can be freed once all threads have moved past E</li> <li>Neutralization: Signal-based mechanism handles stalled threads to bound memory usage</li> </ul>"},{"location":"#why-typestates","title":"Why typestates?","text":"<p>This library uses nim-typestates to enforce the DEBRA+ protocol at compile time:</p> <ul> <li>Compile-time errors: Invalid operation sequences fail at compile time with clear error messages</li> <li>Self-documenting: Types show what operations are valid in each state</li> <li>Zero runtime cost: All validation happens during compilation</li> </ul> <p>For example, you cannot retire an object without being pinned:</p> <pre><code>let handle = registerThread(manager)\n# This won't compile - must pin first!\n# let retired = retireObject(handle, ptr, destructor)\n\n# This is correct:\nlet pinned = handle.pin()\nlet retired = retireObject(pinned, ptr, destructor)\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Typestate-enforced API - Invalid operation sequences fail at compile time</li> <li>Signal-based neutralization - Handles stalled threads for bounded memory usage</li> <li>Limbo bags - Thread-local retire queues organized in 64-object batches</li> <li>Generic implementation - Works with any pointer type and destructor</li> <li>O(mn) memory bound - Where m = threads, n = objects per epoch</li> <li>Zero runtime overhead - Typestate validation happens at compile time</li> </ul>"},{"location":"#memory-reclamation-workflow","title":"Memory Reclamation Workflow","text":"<ol> <li>Manager initialization: Create and initialize a <code>DebraManager[MaxThreads]</code></li> <li>Thread registration: Each thread registers to get a <code>ThreadHandle</code></li> <li>Pin epoch: Enter critical section with <code>pin()</code> to get <code>Pinned</code> state</li> <li>Access shared data: Safely read/write lock-free data structures</li> <li>Retire objects: Mark removed objects for reclamation with <code>retire()</code></li> <li>Unpin epoch: Exit critical section with <code>unpin()</code></li> <li>Reclamation: Background process reclaims objects from old epochs</li> </ol>"},{"location":"#installation","title":"Installation","text":"<pre><code>nimble install debra\n</code></pre> <p>Or add to your <code>.nimble</code> file:</p> <pre><code>requires \"debra &gt;= 0.1.0\"\n</code></pre>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Getting Started - Tutorial walkthrough</li> <li>Concepts - Understanding DEBRA+ algorithm</li> <li>API Reference - Generated API documentation</li> </ul>"},{"location":"#references","title":"References","text":""},{"location":"#foundational-papers","title":"Foundational Papers","text":"<ul> <li>DEBRA+: Efficient Memory Reclamation (Brown, 2017) - The DEBRA+ algorithm with signal-based neutralization</li> <li>Epoch-Based Reclamation (Fraser, 2004) - Original epoch-based memory reclamation approach</li> </ul>"},{"location":"#related-projects","title":"Related Projects","text":"<ul> <li>nim-typestates - Compile-time typestate validation library used by nim-debra</li> <li>lockfreequeues - Lock-free queue implementations using nim-debra for memory reclamation</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#api-reference","title":"API Reference","text":"<p>Auto-generated API documentation from source code.</p>"},{"location":"api/#main-module","title":"Main Module","text":""},{"location":"api/#debra","title":"debra","text":"<p>nim-debra: DEBRA+ Safe Memory Reclamation</p> <p>This library provides typestate-enforced epoch-based reclamation with signal-based neutralization for lock-free data structures.</p>"},{"location":"api/#registerThread","title":"registerThread raises","text":"<pre><code>proc registerThread(manager: var DebraManager[MaxThreads]): ThreadHandle[MaxThreads]</code></pre> <p>Register current thread with the DEBRA manager.</p> <p>Must be called once per thread before any epoch operations. Raises DebraRegistrationError if max threads already registered.</p> Parameters <ul> <li> <code>manager</code>               (<code>var DebraManager[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ThreadHandle[MaxThreads]</code></p> Raises <ul> <li><code>DebraRegistrationError</code></li> </ul> Source:              src/debra.nim:36"},{"location":"api/#neutralizeStalled","title":"neutralizeStalled","text":"<pre><code>proc neutralizeStalled(manager: var DebraManager[MaxThreads]; epochsBeforeNeutralize: uint64 = 2): int</code></pre> <p>Signal all stalled threads. Returns number of signals sent.</p> Parameters <ul> <li> <code>manager</code>               (<code>var DebraManager[MaxThreads]</code>)                            </li> <li> <code>epochsBeforeNeutralize</code>               (<code>uint64</code>)                            </li> </ul> Returns <p><code>int</code></p> Source:              src/debra.nim:55"},{"location":"api/#advance","title":"advance inline","text":"<pre><code>proc advance(manager: var DebraManager[MaxThreads])</code></pre> <p>Advance the global epoch.</p> Parameters <ul> <li> <code>manager</code>               (<code>var DebraManager[MaxThreads]</code>)                            </li> </ul> Source:              src/debra.nim:66"},{"location":"api/#currentEpoch","title":"currentEpoch inline","text":"<pre><code>proc currentEpoch(manager: var DebraManager[MaxThreads]): uint64</code></pre> <p>Get current global epoch.</p> Parameters <ul> <li> <code>manager</code>               (<code>var DebraManager[MaxThreads]</code>)                            </li> </ul> Returns <p><code>uint64</code></p> Source:              src/debra.nim:73"},{"location":"api/#core-types","title":"Core Types","text":"<p>Type definitions for DEBRA+ manager and thread state.</p>"},{"location":"api/#types","title":"types","text":"<p>Core types for DEBRA+ implementation.</p>"},{"location":"api/#ThreadState","title":"ThreadState","text":"<pre><code>type ThreadState</code></pre> Source:              src/debra/types.nim:12"},{"location":"api/#DebraManager","title":"DebraManager","text":"<pre><code>type DebraManager</code></pre> Source:              src/debra/types.nim:30"},{"location":"api/#ThreadHandle","title":"ThreadHandle","text":"<pre><code>type ThreadHandle</code></pre> Source:              src/debra/types.nim:39"},{"location":"api/#DebraRegistrationError","title":"DebraRegistrationError","text":"<pre><code>type DebraRegistrationError</code></pre> Source:              src/debra/types.nim:46"},{"location":"api/#initDebraManager","title":"initDebraManager","text":"<pre><code>proc initDebraManager(): DebraManager[MaxThreads]</code></pre> <p>Initialize a new DEBRA+ manager.</p> <p>The global epoch starts at 1 (not 0) so that epoch 0 can represent \"never observed\" in thread state.</p> Returns <p><code>DebraManager[MaxThreads]</code></p> Source:              src/debra/types.nim:49"},{"location":"api/#constants_1","title":"Constants","text":"<p>Configuration constants for DEBRA+ algorithm.</p>"},{"location":"api/#constants","title":"constants","text":"<p>Constants for DEBRA+ implementation.</p>"},{"location":"api/#DefaultMaxThreads","title":"DefaultMaxThreads","text":"<pre><code>const DefaultMaxThreads</code></pre> <p>Default maximum number of threads that can be registered.</p> Source:              src/debra/constants.nim:6"},{"location":"api/#CacheLineBytes","title":"CacheLineBytes","text":"<pre><code>const CacheLineBytes</code></pre> <p>Cache line size for alignment to prevent false sharing.</p> Source:              src/debra/constants.nim:9"},{"location":"api/#limbo-bags","title":"Limbo Bags","text":"<p>Data structures for thread-local retire queues.</p>"},{"location":"api/#limbo","title":"limbo","text":"<p>Limbo bag data structures for DEBRA+ retire queues.</p> <p>A limbo bag holds up to 64 retired objects. Bags are linked together forming a thread-local retire queue.</p>"},{"location":"api/#LimboBagSize","title":"LimboBagSize","text":"<pre><code>const LimboBagSize</code></pre> Source:              src/debra/limbo.nim:9"},{"location":"api/#Destructor","title":"Destructor","text":"<pre><code>type Destructor</code></pre> Source:              src/debra/limbo.nim:12"},{"location":"api/#RetiredObject","title":"RetiredObject","text":"<pre><code>type RetiredObject</code></pre> Source:              src/debra/limbo.nim:14"},{"location":"api/#LimboBag","title":"LimboBag","text":"<pre><code>type LimboBag</code></pre> Source:              src/debra/limbo.nim:18"},{"location":"api/#allocLimboBag","title":"allocLimboBag","text":"<pre><code>proc allocLimboBag(): ptr LimboBag</code></pre> <p>Allocate a new empty limbo bag.</p> Returns <p><code>ptr LimboBag</code></p> Source:              src/debra/limbo.nim:25"},{"location":"api/#freeLimboBag","title":"freeLimboBag","text":"<pre><code>proc freeLimboBag(bag: ptr LimboBag)</code></pre> <p>Free a limbo bag (does NOT call destructors).</p> Parameters <ul> <li> <code>bag</code>               (<code>ptr LimboBag</code>)                            </li> </ul> Source:              src/debra/limbo.nim:30"},{"location":"api/#reclaimBag","title":"reclaimBag","text":"<pre><code>proc reclaimBag(bag: ptr LimboBag)</code></pre> <p>Call destructors for all objects in bag, then free bag.</p> Parameters <ul> <li> <code>bag</code>               (<code>ptr LimboBag</code>)                            </li> </ul> Source:              src/debra/limbo.nim:35"},{"location":"api/#signal-handling","title":"Signal Handling","text":"<p>POSIX signal handling for neutralization protocol.</p>"},{"location":"api/#signal","title":"signal","text":"<p>Signal handler for DEBRA+ thread neutralization.</p> <p>When a thread is stalled (hasn't advanced its epoch), other threads can send SIGUSR1 to force it to unpin, allowing reclamation to proceed.</p>"},{"location":"api/#installSignalHandler","title":"installSignalHandler","text":"<pre><code>proc installSignalHandler()</code></pre> <p>Install SIGUSR1 handler for DEBRA+ neutralization.</p> <p>Safe to call multiple times - subsequent calls are no-ops. Called automatically during first DebraManager initialization.</p> Source:              src/debra/signal.nim:55"},{"location":"api/#isSignalHandlerInstalled","title":"isSignalHandlerInstalled","text":"<pre><code>proc isSignalHandlerInstalled(): bool</code></pre> <p>Check if signal handler has been installed.</p> Returns <p><code>bool</code></p> Source:              src/debra/signal.nim:72"},{"location":"api/#setGlobalManager","title":"setGlobalManager","text":"<pre><code>proc setGlobalManager(manager: pointer)</code></pre> <p>Set the global manager pointer for signal handler.</p> <p>Must be called once after manager initialization.</p> Parameters <ul> <li> <code>manager</code>               (<code>pointer</code>)                            </li> </ul> Source:              src/debra/signal.nim:77"},{"location":"api/#typestates","title":"Typestates","text":""},{"location":"api/#signal-handler","title":"Signal Handler","text":"<p>Signal handler installation lifecycle.</p>"},{"location":"api/#signal_handler","title":"signal_handler","text":"<p>SignalHandler typestate.</p> <p>Ensures signal handler is installed before DEBRA operations.</p>"},{"location":"api/#SignalHandlerContext","title":"SignalHandlerContext","text":"<pre><code>type SignalHandlerContext</code></pre> Source:              src/debra/typestates/signal_handler.nim:11"},{"location":"api/#HandlerUninstalled","title":"HandlerUninstalled","text":"<pre><code>type HandlerUninstalled</code></pre> Source:              src/debra/typestates/signal_handler.nim:14"},{"location":"api/#HandlerInstalled","title":"HandlerInstalled","text":"<pre><code>type HandlerInstalled</code></pre> Source:              src/debra/typestates/signal_handler.nim:15"},{"location":"api/#initSignalHandler","title":"initSignalHandler","text":"<pre><code>proc initSignalHandler(): HandlerUninstalled</code></pre> <p>Create uninstalled signal handler context.</p> Returns <p><code>HandlerUninstalled</code></p> Source:              src/debra/typestates/signal_handler.nim:29"},{"location":"api/#install","title":"install transition","text":"<pre><code>proc install(h: HandlerUninstalled): HandlerInstalled</code></pre> <p>Install SIGUSR1 handler for DEBRA+ neutralization.</p> Parameters <ul> <li> <code>h</code>               (<code>HandlerUninstalled</code>)                            </li> </ul> Returns <p><code>HandlerInstalled</code></p> Source:              src/debra/typestates/signal_handler.nim:34"},{"location":"api/#isInstalled","title":"isInstalled","text":"<pre><code>func isInstalled(h: HandlerInstalled): bool</code></pre> <p>Check if handler is installed.</p> Parameters <ul> <li> <code>h</code>               (<code>HandlerInstalled</code>)                            </li> </ul> Returns <p><code>bool</code></p> Source:              src/debra/typestates/signal_handler.nim:44"},{"location":"api/#manager_1","title":"Manager","text":"<p>Manager initialization and shutdown lifecycle.</p>"},{"location":"api/#manager","title":"manager","text":"<p>DebraManager lifecycle typestate.</p> <p>Ensures manager is initialized before use and properly shut down.</p>"},{"location":"api/#ManagerContext","title":"ManagerContext","text":"<pre><code>type ManagerContext</code></pre> Source:              src/debra/typestates/manager.nim:13"},{"location":"api/#ManagerUninitialized","title":"ManagerUninitialized","text":"<pre><code>type ManagerUninitialized</code></pre> Source:              src/debra/typestates/manager.nim:16"},{"location":"api/#ManagerReady","title":"ManagerReady","text":"<pre><code>type ManagerReady</code></pre> Source:              src/debra/typestates/manager.nim:17"},{"location":"api/#ManagerShutdown","title":"ManagerShutdown","text":"<pre><code>type ManagerShutdown</code></pre> Source:              src/debra/typestates/manager.nim:18"},{"location":"api/#uninitializedManager","title":"uninitializedManager","text":"<pre><code>proc uninitializedManager(mgr: ptr DebraManager[MaxThreads]): ManagerUninitialized[MaxThreads]</code></pre> <p>Wrap a manager pointer as uninitialized.</p> Parameters <ul> <li> <code>mgr</code>               (<code>ptr DebraManager[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ManagerUninitialized[MaxThreads]</code></p> Source:              src/debra/typestates/manager.nim:28"},{"location":"api/#initialize","title":"initialize transition","text":"<pre><code>proc initialize(m: ManagerUninitialized[MaxThreads]): ManagerReady[MaxThreads]</code></pre> <p>Initialize the manager. Sets epoch to 1, clears all state.</p> Parameters <ul> <li> <code>m</code>               (<code>ManagerUninitialized[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ManagerReady[MaxThreads]</code></p> Source:              src/debra/typestates/manager.nim:35"},{"location":"api/#shutdown","title":"shutdown transition","text":"<pre><code>proc shutdown(m: ManagerReady[MaxThreads]): ManagerShutdown[MaxThreads]</code></pre> <p>Shutdown manager. Reclaims all remaining limbo bags.</p> Parameters <ul> <li> <code>m</code>               (<code>ManagerReady[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ManagerShutdown[MaxThreads]</code></p> Source:              src/debra/typestates/manager.nim:56"},{"location":"api/#getManager","title":"getManager","text":"<pre><code>func getManager(m: ManagerReady[MaxThreads]): ptr DebraManager[MaxThreads]</code></pre> <p>Get the underlying manager pointer.</p> Parameters <ul> <li> <code>m</code>               (<code>ManagerReady[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ptr DebraManager[MaxThreads]</code></p> Source:              src/debra/typestates/manager.nim:80"},{"location":"api/#registration_1","title":"Registration","text":"<p>Thread registration lifecycle.</p>"},{"location":"api/#registration","title":"registration","text":"<p>Registration typestate for thread registration.</p> <p>Handles thread registration with the DEBRA manager, ensuring threads properly claim slots in the thread array using lock-free CAS operations.</p>"},{"location":"api/#RegistrationContext","title":"RegistrationContext","text":"<pre><code>type RegistrationContext</code></pre> Source:              src/debra/typestates/registration.nim:14"},{"location":"api/#Unregistered","title":"Unregistered","text":"<pre><code>type Unregistered</code></pre> Source:              src/debra/typestates/registration.nim:18"},{"location":"api/#Registered","title":"Registered","text":"<pre><code>type Registered</code></pre> Source:              src/debra/typestates/registration.nim:19"},{"location":"api/#RegistrationFull","title":"RegistrationFull","text":"<pre><code>type RegistrationFull</code></pre> Source:              src/debra/typestates/registration.nim:20"},{"location":"api/#unregistered","title":"unregistered","text":"<pre><code>proc unregistered(mgr: ptr DebraManager[MaxThreads]): Unregistered[MaxThreads]</code></pre> <p>Create unregistered context for a thread.</p> Parameters <ul> <li> <code>mgr</code>               (<code>ptr DebraManager[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Unregistered[MaxThreads]</code></p> Source:              src/debra/typestates/registration.nim:29"},{"location":"api/#register","title":"register transition","text":"<pre><code>proc register(u: Unregistered[MaxThreads]): RegisterResult[MaxThreads]</code></pre> <p>Try to register thread by claiming a slot. Returns Registered if successful, RegistrationFull if all slots are taken.</p> Parameters <ul> <li> <code>u</code>               (<code>Unregistered[MaxThreads]</code>)                            </li> </ul> Returns <p><code>RegisterResult[MaxThreads]</code></p> Source:              src/debra/typestates/registration.nim:39"},{"location":"api/#idx","title":"idx","text":"<pre><code>func idx(r: Registered[MaxThreads]): int</code></pre> <p>Get the thread slot index.</p> Parameters <ul> <li> <code>r</code>               (<code>Registered[MaxThreads]</code>)                            </li> </ul> Returns <p><code>int</code></p> Source:              src/debra/typestates/registration.nim:76"},{"location":"api/#getHandle","title":"getHandle","text":"<pre><code>func getHandle(r: Registered[MaxThreads]): ThreadHandle[MaxThreads]</code></pre> <p>Extract ThreadHandle for use in pin/unpin operations.</p> Parameters <ul> <li> <code>r</code>               (<code>Registered[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ThreadHandle[MaxThreads]</code></p> Source:              src/debra/typestates/registration.nim:81"},{"location":"api/#thread-slot","title":"Thread Slot","text":"<p>Thread slot allocation and release.</p>"},{"location":"api/#slot","title":"slot","text":"<p>ThreadSlot typestate for thread slot lifecycle.</p> <p>Tracks the lifecycle of a thread slot in the DEBRA manager: - Free: Slot is available for claiming - Claiming: Thread is attempting to claim the slot - Active: Slot is actively in use by a thread - Draining: Thread is unregistering, draining limbo bags - Free: Slot released back to pool</p>"},{"location":"api/#SlotContext","title":"SlotContext","text":"<pre><code>type SlotContext</code></pre> Source:              src/debra/typestates/slot.nim:15"},{"location":"api/#Free","title":"Free","text":"<pre><code>type Free</code></pre> Source:              src/debra/typestates/slot.nim:19"},{"location":"api/#Claiming","title":"Claiming","text":"<pre><code>type Claiming</code></pre> Source:              src/debra/typestates/slot.nim:20"},{"location":"api/#Active","title":"Active","text":"<pre><code>type Active</code></pre> Source:              src/debra/typestates/slot.nim:21"},{"location":"api/#Draining","title":"Draining","text":"<pre><code>type Draining</code></pre> Source:              src/debra/typestates/slot.nim:22"},{"location":"api/#freeSlot","title":"freeSlot","text":"<pre><code>proc freeSlot(idx: int; mgr: ptr DebraManager[MaxThreads]): Free[MaxThreads]</code></pre> <p>Create a free slot context.</p> Parameters <ul> <li> <code>idx</code>               (<code>int</code>)                            </li> <li> <code>mgr</code>               (<code>ptr DebraManager[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Free[MaxThreads]</code></p> Source:              src/debra/typestates/slot.nim:34"},{"location":"api/#claim","title":"claim transition","text":"<pre><code>proc claim(f: Free[MaxThreads]): Claiming[MaxThreads]</code></pre> <p>Begin claiming this slot. Transition to Claiming state.</p> Parameters <ul> <li> <code>f</code>               (<code>Free[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Claiming[MaxThreads]</code></p> Source:              src/debra/typestates/slot.nim:42"},{"location":"api/#activate","title":"activate transition","text":"<pre><code>proc activate(c: Claiming[MaxThreads]): Active[MaxThreads]</code></pre> <p>Complete slot claim. Transition to Active state. This is where the slot becomes fully owned by a thread.</p> Parameters <ul> <li> <code>c</code>               (<code>Claiming[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Active[MaxThreads]</code></p> Source:              src/debra/typestates/slot.nim:53"},{"location":"api/#drain","title":"drain transition","text":"<pre><code>proc drain(a: Active[MaxThreads]): Draining[MaxThreads]</code></pre> <p>Begin unregistration. Transition to Draining state. Thread will drain its limbo bags before releasing the slot.</p> Parameters <ul> <li> <code>a</code>               (<code>Active[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Draining[MaxThreads]</code></p> Source:              src/debra/typestates/slot.nim:65"},{"location":"api/#release","title":"release transition","text":"<pre><code>proc release(d: Draining[MaxThreads]): Free[MaxThreads]</code></pre> <p>Release slot back to free pool. Transition back to Free state. This completes the lifecycle, making the slot available for reuse.</p> Parameters <ul> <li> <code>d</code>               (<code>Draining[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Free[MaxThreads]</code></p> Source:              src/debra/typestates/slot.nim:77"},{"location":"api/#idx","title":"idx","text":"<pre><code>func idx(s: Active[MaxThreads]): int</code></pre> <p>Get the slot index from Active state.</p> Parameters <ul> <li> <code>s</code>               (<code>Active[MaxThreads]</code>)                            </li> </ul> Returns <p><code>int</code></p> Source:              src/debra/typestates/slot.nim:89"},{"location":"api/#idx","title":"idx","text":"<pre><code>func idx(s: Draining[MaxThreads]): int</code></pre> <p>Get the slot index from Draining state.</p> Parameters <ul> <li> <code>s</code>               (<code>Draining[MaxThreads]</code>)                            </li> </ul> Returns <p><code>int</code></p> Source:              src/debra/typestates/slot.nim:94"},{"location":"api/#manager","title":"manager","text":"<pre><code>func manager(s: Active[MaxThreads]): ptr DebraManager[MaxThreads]</code></pre> <p>Get the manager pointer from Active state.</p> Parameters <ul> <li> <code>s</code>               (<code>Active[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ptr DebraManager[MaxThreads]</code></p> Source:              src/debra/typestates/slot.nim:99"},{"location":"api/#manager","title":"manager","text":"<pre><code>func manager(s: Draining[MaxThreads]): ptr DebraManager[MaxThreads]</code></pre> <p>Get the manager pointer from Draining state.</p> Parameters <ul> <li> <code>s</code>               (<code>Draining[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ptr DebraManager[MaxThreads]</code></p> Source:              src/debra/typestates/slot.nim:104"},{"location":"api/#epoch-guard","title":"Epoch Guard","text":"<p>Pin/unpin critical section lifecycle.</p>"},{"location":"api/#guard","title":"guard","text":"<p>EpochGuard typestate for pin/unpin lifecycle.</p> <p>Ensures threads properly enter/exit critical sections.</p>"},{"location":"api/#EpochGuardContext","title":"EpochGuardContext","text":"<pre><code>type EpochGuardContext</code></pre> Source:              src/debra/typestates/guard.nim:11"},{"location":"api/#Unpinned","title":"Unpinned","text":"<pre><code>type Unpinned</code></pre> Source:              src/debra/typestates/guard.nim:15"},{"location":"api/#Pinned","title":"Pinned","text":"<pre><code>type Pinned</code></pre> Source:              src/debra/typestates/guard.nim:16"},{"location":"api/#Neutralized","title":"Neutralized","text":"<pre><code>type Neutralized</code></pre> Source:              src/debra/typestates/guard.nim:17"},{"location":"api/#unpinned","title":"unpinned","text":"<pre><code>proc unpinned(handle: ThreadHandle[MaxThreads]): Unpinned[MaxThreads]</code></pre> <p>Create unpinned epoch guard context.</p> Parameters <ul> <li> <code>handle</code>               (<code>ThreadHandle[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Unpinned[MaxThreads]</code></p> Source:              src/debra/typestates/guard.nim:28"},{"location":"api/#pin","title":"pin transition","text":"<pre><code>proc pin(u: Unpinned[MaxThreads]): Pinned[MaxThreads]</code></pre> <p>Enter critical section. Blocks reclamation of current epoch.</p> Parameters <ul> <li> <code>u</code>               (<code>Unpinned[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Pinned[MaxThreads]</code></p> Source:              src/debra/typestates/guard.nim:35"},{"location":"api/#unpin","title":"unpin transition","text":"<pre><code>proc unpin(p: Pinned[MaxThreads]): UnpinResult[MaxThreads]</code></pre> <p>Leave critical section. Returns Neutralized if signaled.</p> Parameters <ul> <li> <code>p</code>               (<code>Pinned[MaxThreads]</code>)                            </li> </ul> Returns <p><code>UnpinResult[MaxThreads]</code></p> Source:              src/debra/typestates/guard.nim:51"},{"location":"api/#acknowledge","title":"acknowledge transition","text":"<pre><code>proc acknowledge(n: Neutralized[MaxThreads]): Unpinned[MaxThreads]</code></pre> <p>Acknowledge neutralization. Required before re-pinning.</p> Parameters <ul> <li> <code>n</code>               (<code>Neutralized[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Unpinned[MaxThreads]</code></p> Source:              src/debra/typestates/guard.nim:68"},{"location":"api/#epoch","title":"epoch","text":"<pre><code>func epoch(p: Pinned[MaxThreads]): uint64</code></pre> <p>Get the epoch this thread is pinned at.</p> Parameters <ul> <li> <code>p</code>               (<code>Pinned[MaxThreads]</code>)                            </li> </ul> Returns <p><code>uint64</code></p> Source:              src/debra/typestates/guard.nim:79"},{"location":"api/#handle","title":"handle","text":"<pre><code>func handle(p: Pinned[MaxThreads]): ThreadHandle[MaxThreads]</code></pre> <p>Get the thread handle.</p> Parameters <ul> <li> <code>p</code>               (<code>Pinned[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ThreadHandle[MaxThreads]</code></p> Source:              src/debra/typestates/guard.nim:84"},{"location":"api/#retire_1","title":"Retire","text":"<p>Object retirement to limbo bags.</p>"},{"location":"api/#retire","title":"retire","text":"<p>Retire typestate for adding objects to limbo bags.</p> <p>Must be pinned to retire objects.</p>"},{"location":"api/#RetireContext","title":"RetireContext","text":"<pre><code>type RetireContext</code></pre> Source:              src/debra/typestates/retire.nim:12"},{"location":"api/#RetireReady","title":"RetireReady","text":"<pre><code>type RetireReady</code></pre> Source:              src/debra/typestates/retire.nim:16"},{"location":"api/#Retired","title":"Retired","text":"<pre><code>type Retired</code></pre> Source:              src/debra/typestates/retire.nim:17"},{"location":"api/#retireReady","title":"retireReady","text":"<pre><code>proc retireReady(p: Pinned[MaxThreads]): RetireReady[MaxThreads]</code></pre> <p>Create retire context from pinned state.</p> Parameters <ul> <li> <code>p</code>               (<code>Pinned[MaxThreads]</code>)                            </li> </ul> Returns <p><code>RetireReady[MaxThreads]</code></p> Source:              src/debra/typestates/retire.nim:26"},{"location":"api/#retireReadyFromRetired","title":"retireReadyFromRetired","text":"<pre><code>proc retireReadyFromRetired(r: Retired[MaxThreads]): RetireReady[MaxThreads]</code></pre> <p>Get back to RetireReady after retiring (for multiple retires).</p> Parameters <ul> <li> <code>r</code>               (<code>Retired[MaxThreads]</code>)                            </li> </ul> Returns <p><code>RetireReady[MaxThreads]</code></p> Source:              src/debra/typestates/retire.nim:36"},{"location":"api/#retire","title":"retire transition","text":"<pre><code>proc retire(r: RetireReady[MaxThreads]; data: pointer; destructor: Destructor): Retired[MaxThreads]</code></pre> <p>Retire an object. Will be reclaimed when safe.</p> Parameters <ul> <li> <code>r</code>               (<code>RetireReady[MaxThreads]</code>)                            </li> <li> <code>data</code>               (<code>pointer</code>)                            </li> <li> <code>destructor</code>               (<code>Destructor</code>)                            </li> </ul> Returns <p><code>Retired[MaxThreads]</code></p> Source:              src/debra/typestates/retire.nim:47"},{"location":"api/#handle","title":"handle","text":"<pre><code>func handle(r: RetireReady[MaxThreads]): ThreadHandle[MaxThreads]</code></pre> Parameters <ul> <li> <code>r</code>               (<code>RetireReady[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ThreadHandle[MaxThreads]</code></p> Source:              src/debra/typestates/retire.nim:75"},{"location":"api/#reclamation","title":"Reclamation","text":"<p>Safe memory reclamation from limbo bags.</p>"},{"location":"api/#reclaim","title":"reclaim","text":"<p>Reclaim typestate for safe memory reclamation.</p> <p>Walks limbo bags and reclaims objects retired before safeEpoch.</p>"},{"location":"api/#ReclaimContext","title":"ReclaimContext","text":"<pre><code>type ReclaimContext</code></pre> Source:              src/debra/typestates/reclaim.nim:12"},{"location":"api/#ReclaimStart","title":"ReclaimStart","text":"<pre><code>type ReclaimStart</code></pre> Source:              src/debra/typestates/reclaim.nim:17"},{"location":"api/#EpochsLoaded","title":"EpochsLoaded","text":"<pre><code>type EpochsLoaded</code></pre> Source:              src/debra/typestates/reclaim.nim:18"},{"location":"api/#ReclaimReady","title":"ReclaimReady","text":"<pre><code>type ReclaimReady</code></pre> Source:              src/debra/typestates/reclaim.nim:19"},{"location":"api/#ReclaimBlocked","title":"ReclaimBlocked","text":"<pre><code>type ReclaimBlocked</code></pre> Source:              src/debra/typestates/reclaim.nim:20"},{"location":"api/#reclaimStart","title":"reclaimStart","text":"<pre><code>proc reclaimStart(mgr: ptr DebraManager[MaxThreads]): ReclaimStart[MaxThreads]</code></pre> <p>Begin reclamation attempt.</p> Parameters <ul> <li> <code>mgr</code>               (<code>ptr DebraManager[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ReclaimStart[MaxThreads]</code></p> Source:              src/debra/typestates/reclaim.nim:30"},{"location":"api/#loadEpochs","title":"loadEpochs transition","text":"<pre><code>proc loadEpochs(s: ReclaimStart[MaxThreads]): EpochsLoaded[MaxThreads]</code></pre> <p>Load global epoch and compute minimum epoch across pinned threads.</p> Parameters <ul> <li> <code>s</code>               (<code>ReclaimStart[MaxThreads]</code>)                            </li> </ul> Returns <p><code>EpochsLoaded[MaxThreads]</code></p> Source:              src/debra/typestates/reclaim.nim:41"},{"location":"api/#safeEpoch","title":"safeEpoch","text":"<pre><code>func safeEpoch(e: EpochsLoaded[MaxThreads]): uint64</code></pre> Parameters <ul> <li> <code>e</code>               (<code>EpochsLoaded[MaxThreads]</code>)                            </li> </ul> Returns <p><code>uint64</code></p> Source:              src/debra/typestates/reclaim.nim:58"},{"location":"api/#checkSafe","title":"checkSafe transition","text":"<pre><code>proc checkSafe(e: EpochsLoaded[MaxThreads]): ReclaimCheck[MaxThreads]</code></pre> <p>Check if any epochs are safe to reclaim.</p> Parameters <ul> <li> <code>e</code>               (<code>EpochsLoaded[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ReclaimCheck[MaxThreads]</code></p> Source:              src/debra/typestates/reclaim.nim:62"},{"location":"api/#tryReclaim","title":"tryReclaim notATransition","text":"<pre><code>proc tryReclaim(r: ReclaimReady[MaxThreads]): int</code></pre> <p>Reclaim all eligible objects from all threads' limbo bags. Returns count of objects reclaimed.</p> Parameters <ul> <li> <code>r</code>               (<code>ReclaimReady[MaxThreads]</code>)                            </li> </ul> Returns <p><code>int</code></p> Source:              src/debra/typestates/reclaim.nim:73"},{"location":"api/#neutralization","title":"Neutralization","text":"<p>Thread neutralization protocol.</p>"},{"location":"api/#neutralize","title":"neutralize","text":"<p>Neutralize typestate for DEBRA+ neutralization signaling.</p> <p>Ensures proper sequence: ScanStart -&gt; Scanning -&gt; ScanComplete</p> <p>When the epoch needs to advance, scan all threads and send SIGUSR1 to pinned threads that are stalled (behind globalEpoch by threshold).</p>"},{"location":"api/#NeutralizeContext","title":"NeutralizeContext","text":"<pre><code>type NeutralizeContext</code></pre> Source:              src/debra/typestates/neutralize.nim:16"},{"location":"api/#ScanStart","title":"ScanStart","text":"<pre><code>type ScanStart</code></pre> Source:              src/debra/typestates/neutralize.nim:22"},{"location":"api/#Scanning","title":"Scanning","text":"<pre><code>type Scanning</code></pre> Source:              src/debra/typestates/neutralize.nim:23"},{"location":"api/#ScanComplete","title":"ScanComplete","text":"<pre><code>type ScanComplete</code></pre> Source:              src/debra/typestates/neutralize.nim:24"},{"location":"api/#scanStart","title":"scanStart","text":"<pre><code>proc scanStart(mgr: ptr DebraManager[MaxThreads]): ScanStart[MaxThreads]</code></pre> <p>Begin neutralization scan.</p> Parameters <ul> <li> <code>mgr</code>               (<code>ptr DebraManager[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ScanStart[MaxThreads]</code></p> Source:              src/debra/typestates/neutralize.nim:34"},{"location":"api/#loadEpoch","title":"loadEpoch transition","text":"<pre><code>proc loadEpoch(s: ScanStart[MaxThreads]; epochsBeforeNeutralize: uint64 = 2): Scanning[MaxThreads]</code></pre> <p>Load global epoch and compute threshold for stalled threads. Threads with epoch &lt; (globalEpoch - epochsBeforeNeutralize) get signaled.</p> Parameters <ul> <li> <code>s</code>               (<code>ScanStart[MaxThreads]</code>)                            </li> <li> <code>epochsBeforeNeutralize</code>               (<code>uint64</code>)                            </li> </ul> Returns <p><code>Scanning[MaxThreads]</code></p> Source:              src/debra/typestates/neutralize.nim:46"},{"location":"api/#globalEpoch","title":"globalEpoch","text":"<pre><code>func globalEpoch(s: Scanning[MaxThreads]): uint64</code></pre> <p>Get the global epoch loaded during scan start.</p> Parameters <ul> <li> <code>s</code>               (<code>Scanning[MaxThreads]</code>)                            </li> </ul> Returns <p><code>uint64</code></p> Source:              src/debra/typestates/neutralize.nim:63"},{"location":"api/#threshold","title":"threshold","text":"<pre><code>func threshold(s: Scanning[MaxThreads]): uint64</code></pre> <p>Get the epoch threshold for neutralization.</p> Parameters <ul> <li> <code>s</code>               (<code>Scanning[MaxThreads]</code>)                            </li> </ul> Returns <p><code>uint64</code></p> Source:              src/debra/typestates/neutralize.nim:68"},{"location":"api/#scanAndSignal","title":"scanAndSignal transition","text":"<pre><code>proc scanAndSignal(s: Scanning[MaxThreads]): ScanComplete[MaxThreads]</code></pre> <p>Scan all registered threads and send SIGUSR1 to stalled pinned threads. Returns count of signals sent.</p> Parameters <ul> <li> <code>s</code>               (<code>Scanning[MaxThreads]</code>)                            </li> </ul> Returns <p><code>ScanComplete[MaxThreads]</code></p> Source:              src/debra/typestates/neutralize.nim:73"},{"location":"api/#signalsSent","title":"signalsSent","text":"<pre><code>func signalsSent(c: ScanComplete[MaxThreads]): int</code></pre> <p>Get number of signals sent during scan.</p> Parameters <ul> <li> <code>c</code>               (<code>ScanComplete[MaxThreads]</code>)                            </li> </ul> Returns <p><code>int</code></p> Source:              src/debra/typestates/neutralize.nim:99"},{"location":"api/#extractSignalCount","title":"extractSignalCount","text":"<pre><code>func extractSignalCount(c: ScanComplete[MaxThreads]): int</code></pre> <p>Extract the count of signals sent. Terminal operation.</p> Parameters <ul> <li> <code>c</code>               (<code>ScanComplete[MaxThreads]</code>)                            </li> </ul> Returns <p><code>int</code></p> Source:              src/debra/typestates/neutralize.nim:104"},{"location":"api/#epoch-advance","title":"Epoch Advance","text":"<p>Global epoch advancement.</p>"},{"location":"api/#advance","title":"advance","text":"<p>EpochAdvance typestate for advancing the global epoch.</p> <p>Ensures atomic increment of the global epoch counter.</p>"},{"location":"api/#AdvanceContext","title":"AdvanceContext","text":"<pre><code>type AdvanceContext</code></pre> Source:              src/debra/typestates/advance.nim:11"},{"location":"api/#Current","title":"Current","text":"<pre><code>type Current</code></pre> Source:              src/debra/typestates/advance.nim:16"},{"location":"api/#Advancing","title":"Advancing","text":"<pre><code>type Advancing</code></pre> Source:              src/debra/typestates/advance.nim:17"},{"location":"api/#Advanced","title":"Advanced","text":"<pre><code>type Advanced</code></pre> Source:              src/debra/typestates/advance.nim:18"},{"location":"api/#advanceCurrent","title":"advanceCurrent","text":"<pre><code>proc advanceCurrent(mgr: ptr DebraManager[MaxThreads]): Current[MaxThreads]</code></pre> <p>Create epoch advance context.</p> Parameters <ul> <li> <code>mgr</code>               (<code>ptr DebraManager[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Current[MaxThreads]</code></p> Source:              src/debra/typestates/advance.nim:28"},{"location":"api/#advance","title":"advance transition","text":"<pre><code>proc advance(c: Current[MaxThreads]): Advancing[MaxThreads]</code></pre> <p>Begin advancing the global epoch.</p> Parameters <ul> <li> <code>c</code>               (<code>Current[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Advancing[MaxThreads]</code></p> Source:              src/debra/typestates/advance.nim:39"},{"location":"api/#complete","title":"complete transition","text":"<pre><code>proc complete(a: Advancing[MaxThreads]): Advanced[MaxThreads]</code></pre> <p>Complete epoch advance by atomically incrementing globalEpoch.</p> Parameters <ul> <li> <code>a</code>               (<code>Advancing[MaxThreads]</code>)                            </li> </ul> Returns <p><code>Advanced[MaxThreads]</code></p> Source:              src/debra/typestates/advance.nim:52"},{"location":"api/#newEpoch","title":"newEpoch","text":"<pre><code>func newEpoch(a: Advanced[MaxThreads]): uint64</code></pre> <p>Get the new epoch value after advancement.</p> Parameters <ul> <li> <code>a</code>               (<code>Advanced[MaxThreads]</code>)                            </li> </ul> Returns <p><code>uint64</code></p> Source:              src/debra/typestates/advance.nim:70"},{"location":"api/#oldEpoch","title":"oldEpoch","text":"<pre><code>func oldEpoch(a: Advanced[MaxThreads]): uint64</code></pre> <p>Get the old epoch value before advancement.</p> Parameters <ul> <li> <code>a</code>               (<code>Advanced[MaxThreads]</code>)                            </li> </ul> Returns <p><code>uint64</code></p> Source:              src/debra/typestates/advance.nim:75"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome! This document outlines how to contribute to nim-debra.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li> <p>Clone the repository: </p><pre><code>git clone https://github.com/elijahr/nim-debra.git\ncd nim-debra\n</code></pre><p></p> </li> <li> <p>Install dependencies: </p><pre><code>nimble install -d\n</code></pre><p></p> </li> <li> <p>Run tests: </p><pre><code>nimble test\n</code></pre><p></p> </li> </ol>"},{"location":"contributing/#testing","title":"Testing","text":"<p>All changes should include tests. The test suite is located in <code>tests/</code>:</p> <ul> <li>Unit tests for individual typestates in <code>tests/t_*.nim</code></li> <li>Integration tests in <code>tests/t_integration.nim</code></li> <li>Main test runner in <code>tests/test.nim</code></li> </ul> <p>Run tests with: </p><pre><code>nimble test\n</code></pre><p></p>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow standard Nim style conventions</li> <li>Use meaningful variable and function names</li> <li>Add documentation comments for public APIs</li> <li>Keep functions focused and single-purpose</li> </ul>"},{"location":"contributing/#typestate-design","title":"Typestate Design","text":"<p>When adding or modifying typestates:</p> <ol> <li>Define states as <code>distinct</code> types wrapping a context object</li> <li>Use <code>typestate</code> block to declare valid transitions</li> <li>Mark transition functions with <code>{.transition.}</code> pragma</li> <li>Write tests that verify both valid and invalid transitions</li> </ol> <p>Example: </p><pre><code>type\n  Context = object\n    data: int\n  StateA = distinct Context\n  StateB = distinct Context\n\ntypestate Context:\n  states StateA, StateB\n  transitions:\n    StateA -&gt; StateB\n\nproc transition(a: StateA): StateB {.transition.} =\n  StateB(a.Context)\n</code></pre><p></p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<ul> <li>Add docstrings to all public procs and types</li> <li>Update relevant guide pages in <code>docs/guide/</code></li> <li>Run <code>mkdocs serve</code> to preview documentation locally</li> </ul>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<ol> <li>Create a feature branch from <code>main</code></li> <li>Make your changes with clear commit messages</li> <li>Add tests for new functionality</li> <li>Update documentation as needed</li> <li>Submit a pull request</li> </ol>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>Open an issue on GitHub or start a discussion.</p>"},{"location":"guide/concepts/","title":"Concepts","text":""},{"location":"guide/concepts/#debra-concepts","title":"DEBRA+ Concepts","text":"<p>Understanding the core concepts behind DEBRA+ memory reclamation.</p>"},{"location":"guide/concepts/#the-memory-reclamation-problem","title":"The Memory Reclamation Problem","text":"<p>In lock-free data structures, traditional memory management approaches fail:</p> <ul> <li>Garbage collection: Adds unpredictable latency and runtime overhead</li> <li>Reference counting: Expensive atomic operations on every access</li> <li>Manual management: Race conditions lead to use-after-free or memory leaks</li> </ul> <p>DEBRA+ provides a middle ground: explicit reclamation with safety guarantees.</p>"},{"location":"guide/concepts/#epoch-based-reclamation","title":"Epoch-Based Reclamation","text":"<p>DEBRA+ uses epochs to track when memory can be safely reclaimed:</p> <ol> <li>Global epoch counter: Monotonically increasing integer</li> <li>Thread epochs: Each active thread pins a specific epoch</li> <li>Retire queues: Objects retired in each epoch</li> <li>Reclamation rule: Objects retired in epoch E are safe to free once all threads have advanced past E</li> </ol>"},{"location":"guide/concepts/#example-timeline","title":"Example Timeline","text":"<pre><code>Time    Global  Thread1  Thread2  Action\n----    ------  -------  -------  ------\nt0      1       -        -        Start\nt1      1       1        -        Thread1 pins epoch 1\nt2      1       1        1        Thread2 pins epoch 1\nt3      2       1        1        Epoch advances to 2\nt4      2       2        1        Thread1 unpins, repins at 2\nt5      2       2        2        Thread2 unpins, repins at 2\nt6      2       2        2        Objects retired at epoch 1 can now be freed\n</code></pre>"},{"location":"guide/concepts/#pinunpin-protocol","title":"Pin/Unpin Protocol","text":"<p>Threads must pin the current epoch before accessing lock-free data structures:</p> <pre><code># WRONG - not protected\nlet value = queue.dequeue()\n\n# RIGHT - pinned during access\nlet pinned = handle.pin()\nlet value = queue.dequeue()\ndiscard pinned.unpin()\n</code></pre> <p>Pinning tells the reclamation system: \"I might be accessing objects from this epoch.\"</p>"},{"location":"guide/concepts/#limbo-bags","title":"Limbo Bags","text":"<p>Retired objects are stored in thread-local limbo bags:</p> <ul> <li>Each bag holds up to 64 objects</li> <li>Bags are linked together forming a retire queue</li> <li>Objects include destructor pointers for cleanup</li> <li>Organized by retirement epoch</li> </ul>"},{"location":"guide/concepts/#limbo-bag-structure","title":"Limbo Bag Structure","text":"<pre><code>Thread State\n  currentBag --&gt; [Bag: epoch=5, count=23] --&gt; [Bag: epoch=4, count=64] --&gt; ...\n                         ^                            ^\n                     limboBagHead                limboBagTail\n</code></pre>"},{"location":"guide/concepts/#safe-reclamation","title":"Safe Reclamation","text":"<p>Reclamation walks the limbo bags and frees objects from old epochs:</p> <ol> <li>Load epochs: Read global epoch and all thread epochs</li> <li>Compute safe epoch: Minimum of all pinned thread epochs</li> <li>Walk limbo bags: From oldest (tail) toward newest (head)</li> <li>Reclaim eligible: Free bags where <code>bag.epoch &lt; safeEpoch - 1</code></li> <li>Stop at barrier: Once we hit a bag that's still unsafe, stop</li> </ol>"},{"location":"guide/concepts/#neutralization","title":"Neutralization","text":"<p>What if a thread stalls while pinned? It blocks reclamation indefinitely.</p> <p>DEBRA+ solves this with neutralization:</p> <ol> <li>Detection: During reclamation, detect threads pinned at old epochs</li> <li>Signal: Send SIGUSR1 to stalled thread's OS process</li> <li>Handler: Signal handler sets neutralization flag</li> <li>Acknowledgment: Thread checks flag on unpin and handles it</li> <li>Recovery: Thread acknowledges, allowing epoch to advance</li> </ol>"},{"location":"guide/concepts/#neutralization-flow","title":"Neutralization Flow","text":"<pre><code># Thread 1: Pinned and working\nlet pinned = handle.pin()\n# ... long computation ...\nlet result = pinned.unpin()\nif result.kind == uNeutralized:\n  # We were neutralized - acknowledge it\n  let unpinned = result.neutralized.acknowledge()\n</code></pre>"},{"location":"guide/concepts/#memory-bounds","title":"Memory Bounds","text":"<p>DEBRA+ guarantees O(mn) memory overhead where:</p> <ul> <li>m = number of threads</li> <li>n = maximum objects retired per epoch per thread</li> </ul> <p>Without neutralization, a stalled thread could accumulate unbounded memory. Neutralization ensures bounded growth.</p>"},{"location":"guide/concepts/#typestate-enforcement","title":"Typestate Enforcement","text":"<p>nim-debra uses compile-time typestates to enforce correct protocol usage:</p> <ul> <li>Cannot retire without being pinned</li> <li>Cannot pin without registering</li> <li>Must acknowledge neutralization before re-pinning</li> </ul> <p>These invariants are checked at compile time, not runtime.</p>"},{"location":"guide/concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about thread registration</li> <li>Understand pin/unpin lifecycle</li> <li>Deep dive into neutralization</li> </ul>"},{"location":"guide/getting-started/","title":"Getting Started","text":""},{"location":"guide/getting-started/#getting-started","title":"Getting Started","text":"<p>This guide walks through setting up and using nim-debra in your lock-free data structures.</p>"},{"location":"guide/getting-started/#installation","title":"Installation","text":"<p>Add nim-debra to your <code>.nimble</code> file:</p> <pre><code>requires \"debra &gt;= 0.1.0\"\n</code></pre> <p>Or install globally:</p> <pre><code>nimble install debra\n</code></pre>"},{"location":"guide/getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"guide/getting-started/#1-initialize-the-manager","title":"1. Initialize the Manager","text":"<p>Create a DEBRA manager once per process. The generic parameter specifies the maximum number of threads:</p> <pre><code>import debra\n\n# Support up to 64 threads\nvar manager: DebraManager[64]\n</code></pre>"},{"location":"guide/getting-started/#2-initialize-and-set-global-manager","title":"2. Initialize and Set Global Manager","text":"<pre><code># Initialize the manager\nlet ready = uninitializedManager(addr manager).initialize()\n\n# Optional: set as global for convenience\nsetGlobalManager(ready.getManager())\n</code></pre>"},{"location":"guide/getting-started/#3-register-threads","title":"3. Register Threads","text":"<p>Each thread must register before using DEBRA operations:</p> <pre><code># In each thread:\nlet handle = registerThread(addr manager)\n</code></pre>"},{"location":"guide/getting-started/#4-pinunpin-critical-sections","title":"4. Pin/Unpin Critical Sections","text":"<p>Wrap lock-free data structure access in pin/unpin:</p> <pre><code># Enter critical section\nlet pinned = handle.pin()\n\n# Access your lock-free data structure here\nlet value = myQueue.dequeue()\n\n# Exit critical section\ndiscard pinned.unpin()\n</code></pre>"},{"location":"guide/getting-started/#5-retire-objects","title":"5. Retire Objects","text":"<p>When removing objects from your data structure, retire them for later reclamation:</p> <pre><code>proc nodeDestructor(p: pointer) {.nimcall.} =\n  let node = cast[ptr Node](p)\n  dealloc(node)\n\nlet pinned = handle.pin()\nlet node = myQueue.dequeue()\nlet ready = retireReady(pinned)\ndiscard ready.retire(cast[pointer](node), nodeDestructor)\ndiscard pinned.unpin()\n</code></pre>"},{"location":"guide/getting-started/#6-periodic-reclamation","title":"6. Periodic Reclamation","text":"<p>Periodically attempt to reclaim retired objects:</p> <pre><code># In a background thread or after operations:\nlet result = reclaimStart(addr manager)\n  .loadEpochs()\n  .checkSafe()\n\nif result.kind == rReclaimReady:\n  let count = result.reclaimready.tryReclaim()\n  echo \"Reclaimed \", count, \" objects\"\n</code></pre>"},{"location":"guide/getting-started/#complete-example","title":"Complete Example","text":"<pre><code>import debra\n\n# Node type for lock-free queue\ntype Node = object\n  value: int\n  next: ptr Node\n\nproc destroyNode(p: pointer) {.nimcall.} =\n  dealloc(p)\n\n# Initialize manager\nvar manager: DebraManager[4]\ndiscard uninitializedManager(addr manager).initialize()\n\n# Thread function\nproc workerThread() =\n  # Register thread\n  let handle = registerThread(addr manager)\n\n  # Work loop\n  for i in 0..&lt;1000:\n    # Critical section\n    let pinned = handle.pin()\n\n    # ... access lock-free data ...\n\n    # Retire removed node\n    if nodeToRemove != nil:\n      let ready = retireReady(pinned)\n      discard ready.retire(cast[pointer](nodeToRemove), destroyNode)\n\n    discard pinned.unpin()\n\n    # Periodic reclamation\n    if i mod 100 == 0:\n      let result = reclaimStart(addr manager)\n        .loadEpochs()\n        .checkSafe()\n      if result.kind == rReclaimReady:\n        discard result.reclaimready.tryReclaim()\n</code></pre>"},{"location":"guide/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about DEBRA+ concepts</li> <li>Understand thread registration</li> <li>Deep dive into retiring objects</li> </ul>"},{"location":"guide/integration/","title":"Integration","text":""},{"location":"guide/integration/#integration","title":"Integration","text":"<p>Integrating nim-debra with lock-free data structures.</p>"},{"location":"guide/integration/#overview","title":"Overview","text":"<p>This guide shows how to integrate nim-debra into lock-free data structures for safe memory reclamation.</p>"},{"location":"guide/integration/#basic-integration-pattern","title":"Basic Integration Pattern","text":""},{"location":"guide/integration/#1-add-debra-manager-to-structure","title":"1. Add DEBRA Manager to Structure","text":"<pre><code>import debra\n\ntype LockFreeQueue[T] = object\n  head: Atomic[ptr Node[T]]\n  tail: Atomic[ptr Node[T]]\n  manager: ptr DebraManager[64]  # Add manager reference\n  handle: ThreadHandle[64]       # Per-thread handle\n</code></pre>"},{"location":"guide/integration/#2-initialize-manager","title":"2. Initialize Manager","text":"<pre><code>proc initLockFreeQueue[T](manager: ptr DebraManager[64]): LockFreeQueue[T] =\n  result.head.store(nil, moRelaxed)\n  result.tail.store(nil, moRelaxed)\n  result.manager = manager\n  result.handle = registerThread(manager)\n</code></pre>"},{"location":"guide/integration/#3-pin-during-operations","title":"3. Pin During Operations","text":"<pre><code>proc enqueue[T](queue: var LockFreeQueue[T], value: T) =\n  let pinned = queue.handle.pin()\n\n  # Lock-free enqueue operation\n  let newNode = allocNode(value)\n  # ... CAS operations ...\n\n  discard pinned.unpin()\n</code></pre>"},{"location":"guide/integration/#4-retire-removed-nodes","title":"4. Retire Removed Nodes","text":"<pre><code>proc dequeue[T](queue: var LockFreeQueue[T]): Option[T] =\n  let pinned = queue.handle.pin()\n\n  let head = queue.head.load(moAcquire)\n  if head == nil:\n    discard pinned.unpin()\n    return none(T)\n\n  let next = head.next.load(moRelaxed)\n  queue.head.store(next, moRelease)\n\n  # Retire old head\n  let ready = retireReady(pinned)\n  discard ready.retire(cast[pointer](head), destroyNode[T])\n\n  let result = some(head.value)\n  discard pinned.unpin()\n  result\n</code></pre>"},{"location":"guide/integration/#complete-example-lock-free-stack","title":"Complete Example: Lock-Free Stack","text":"<pre><code>import debra\nimport std/[atomics, options]\n\n# Node type\ntype\n  Node[T] = object\n    value: T\n    next: Atomic[ptr Node[T]]\n\n  LockFreeStack[T] = object\n    top: Atomic[ptr Node[T]]\n    manager: ptr DebraManager[64]\n    handle: ThreadHandle[64]\n\n# Node destructor\nproc destroyNode[T](p: pointer) {.nimcall.} =\n  let node = cast[ptr Node[T]](p)\n  dealloc(node)\n\n# Initialize stack\nproc initStack[T](manager: ptr DebraManager[64]): LockFreeStack[T] =\n  result.top.store(nil, moRelaxed)\n  result.manager = manager\n  result.handle = registerThread(manager)\n\n# Push operation\nproc push[T](stack: var LockFreeStack[T], value: T) =\n  let pinned = stack.handle.pin()\n\n  let newNode = cast[ptr Node[T]](alloc(sizeof(Node[T])))\n  newNode.value = value\n\n  var done = false\n  while not done:\n    let oldTop = stack.top.load(moAcquire)\n    newNode.next.store(oldTop, moRelaxed)\n\n    if stack.top.compareExchange(oldTop, newNode, moRelease, moRelaxed):\n      done = true\n\n  discard pinned.unpin()\n\n# Pop operation\nproc pop[T](stack: var LockFreeStack[T]): Option[T] =\n  let pinned = stack.handle.pin()\n\n  var done = false\n  var result: Option[T] = none(T)\n\n  while not done:\n    let oldTop = stack.top.load(moAcquire)\n\n    if oldTop == nil:\n      done = true\n    else:\n      let next = oldTop.next.load(moRelaxed)\n\n      if stack.top.compareExchange(oldTop, next, moRelease, moRelaxed):\n        result = some(oldTop.value)\n\n        # Retire old top\n        let ready = retireReady(pinned)\n        discard ready.retire(cast[pointer](oldTop), destroyNode[T])\n\n        done = true\n\n  discard pinned.unpin()\n  result\n\n# Usage\nvar manager: DebraManager[64]\ndiscard uninitializedManager(addr manager).initialize()\n\nvar stack = initStack[int](addr manager)\nstack.push(42)\necho stack.pop()  # Some(42)\n</code></pre>"},{"location":"guide/integration/#lock-free-queue-example","title":"Lock-Free Queue Example","text":"<pre><code>import debra\nimport std/[atomics, options]\n\ntype\n  QueueNode[T] = object\n    value: T\n    next: Atomic[ptr QueueNode[T]]\n\n  LockFreeQueue[T] = object\n    head: Atomic[ptr QueueNode[T]]\n    tail: Atomic[ptr QueueNode[T]]\n    manager: ptr DebraManager[64]\n    handle: ThreadHandle[64]\n\nproc destroyQueueNode[T](p: pointer) {.nimcall.} =\n  dealloc(p)\n\nproc initQueue[T](manager: ptr DebraManager[64]): LockFreeQueue[T] =\n  # Sentinel node\n  let sentinel = cast[ptr QueueNode[T]](alloc(sizeof(QueueNode[T])))\n  sentinel.next.store(nil, moRelaxed)\n\n  result.head.store(sentinel, moRelaxed)\n  result.tail.store(sentinel, moRelaxed)\n  result.manager = manager\n  result.handle = registerThread(manager)\n\nproc enqueue[T](queue: var LockFreeQueue[T], value: T) =\n  let pinned = queue.handle.pin()\n\n  let newNode = cast[ptr QueueNode[T]](alloc(sizeof(QueueNode[T])))\n  newNode.value = value\n  newNode.next.store(nil, moRelaxed)\n\n  var done = false\n  while not done:\n    let tail = queue.tail.load(moAcquire)\n    let next = tail.next.load(moAcquire)\n\n    if next == nil:\n      if tail.next.compareExchange(nil, newNode, moRelease, moRelaxed):\n        discard queue.tail.compareExchange(tail, newNode, moRelease, moRelaxed)\n        done = true\n    else:\n      discard queue.tail.compareExchange(tail, next, moRelease, moRelaxed)\n\n  discard pinned.unpin()\n\nproc dequeue[T](queue: var LockFreeQueue[T]): Option[T] =\n  let pinned = queue.handle.pin()\n\n  var done = false\n  var result: Option[T] = none(T)\n\n  while not done:\n    let head = queue.head.load(moAcquire)\n    let tail = queue.tail.load(moAcquire)\n    let next = head.next.load(moAcquire)\n\n    if next != nil:\n      if queue.head.compareExchange(head, next, moRelease, moRelaxed):\n        result = some(next.value)\n\n        # Retire old head\n        let ready = retireReady(pinned)\n        discard ready.retire(cast[pointer](head), destroyQueueNode[T])\n\n        done = true\n    else:\n      done = true  # Queue is empty\n\n  discard pinned.unpin()\n  result\n</code></pre>"},{"location":"guide/integration/#multi-threaded-integration","title":"Multi-Threaded Integration","text":""},{"location":"guide/integration/#shared-manager-per-thread-handles","title":"Shared Manager, Per-Thread Handles","text":"<pre><code>var globalManager: DebraManager[64]\n\nproc initGlobal() =\n  discard uninitializedManager(addr globalManager).initialize()\n\nproc workerThread(id: int) {.thread.} =\n  # Each thread registers once\n  let handle = registerThread(addr globalManager)\n\n  var stack = LockFreeStack[int]()\n  stack.manager = addr globalManager\n  stack.handle = handle  # Use this thread's handle\n\n  for i in 0..&lt;1000:\n    stack.push(i)\n    discard stack.pop()\n\n# Main\ninitGlobal()\nvar threads: array[8, Thread[int]]\nfor i in 0..&lt;8:\n  createThread(threads[i], workerThread, i)\nfor i in 0..&lt;8:\n  joinThreads(threads[i])\n</code></pre>"},{"location":"guide/integration/#reclamation-strategies","title":"Reclamation Strategies","text":""},{"location":"guide/integration/#background-reclamation-thread","title":"Background Reclamation Thread","text":"<pre><code>var shouldStop = false\n\nproc reclaimerThread() {.thread.} =\n  while not shouldStop:\n    let result = reclaimStart(addr globalManager)\n      .loadEpochs()\n      .checkSafe()\n\n    if result.kind == rReclaimReady:\n      discard result.reclaimready.tryReclaim()\n\n    sleep(10)  # 10ms interval\n\nvar reclaimer: Thread[void]\ncreateThread(reclaimer, reclaimerThread)\n</code></pre>"},{"location":"guide/integration/#per-operation-reclamation","title":"Per-Operation Reclamation","text":"<pre><code>var opsSinceReclaim = 0\n\nproc push[T](stack: var LockFreeStack[T], value: T) =\n  # ... normal push operation ...\n\n  inc opsSinceReclaim\n  if opsSinceReclaim &gt;= 100:\n    opsSinceReclaim = 0\n    let result = reclaimStart(stack.manager)\n      .loadEpochs()\n      .checkSafe()\n    if result.kind == rReclaimReady:\n      discard result.reclaimready.tryReclaim()\n</code></pre>"},{"location":"guide/integration/#best-practices","title":"Best Practices","text":""},{"location":"guide/integration/#1-minimize-critical-section-duration","title":"1. Minimize Critical Section Duration","text":"<pre><code># GOOD\nproc operation() =\n  let pinned = handle.pin()\n  let data = loadSharedData()\n  discard pinned.unpin()\n  processData(data)  # Outside critical section\n\n# BAD\nproc operation() =\n  let pinned = handle.pin()\n  let data = loadSharedData()\n  processData(data)  # Inside critical section!\n  discard pinned.unpin()\n</code></pre>"},{"location":"guide/integration/#2-batch-retirements","title":"2. Batch Retirements","text":"<pre><code>proc clearAll() =\n  let pinned = handle.pin()\n  var ready = retireReady(pinned)\n\n  while true:\n    let node = removeNode()\n    if node == nil: break\n\n    let retired = ready.retire(cast[pointer](node), destroy)\n    ready = retireReadyFromRetired(retired)\n\n  discard pinned.unpin()\n</code></pre>"},{"location":"guide/integration/#3-handle-neutralization","title":"3. Handle Neutralization","text":"<pre><code>proc robustOperation() =\n  var done = false\n  while not done:\n    let pinned = handle.pin()\n    performOperation()\n    let result = pinned.unpin()\n\n    case result.kind:\n    of uUnpinned:\n      done = true\n    of uNeutralized:\n      discard result.neutralized.acknowledge()\n      # Will retry\n</code></pre>"},{"location":"guide/integration/#4-periodic-reclamation","title":"4. Periodic Reclamation","text":"<pre><code>const ReclaimInterval = 100\n\nvar opsCount = 0\n\nproc afterOperation() =\n  inc opsCount\n  if opsCount mod ReclaimInterval == 0:\n    tryReclaim()\n</code></pre>"},{"location":"guide/integration/#debugging-integration","title":"Debugging Integration","text":""},{"location":"guide/integration/#check-manager-state","title":"Check Manager State","text":"<pre><code>proc dumpManagerState(manager: ptr DebraManager[64]) =\n  echo \"Global epoch: \", manager.globalEpoch.load(moRelaxed)\n  echo \"Active threads: \", manager.activeThreadMask.load(moRelaxed)\n\n  for i in 0..&lt;64:\n    if manager.threads[i].pinned.load(moRelaxed):\n      echo \"  Thread \", i, \": epoch=\", manager.threads[i].epoch.load(moRelaxed)\n</code></pre>"},{"location":"guide/integration/#track-memory-usage","title":"Track Memory Usage","text":"<pre><code>proc countRetiredObjects(manager: ptr DebraManager[64]): int =\n  for i in 0..&lt;64:\n    var bag = manager.threads[i].limboBagHead\n    while bag != nil:\n      result += bag.count\n      bag = bag.next\n</code></pre>"},{"location":"guide/integration/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"guide/integration/#forgetting-to-pin","title":"Forgetting to Pin","text":"<pre><code># WRONG - accessing shared data without pinning\nlet value = queue.head.load(moAcquire).value\n\n# RIGHT - pin before access\nlet pinned = handle.pin()\nlet value = queue.head.load(moAcquire).value\ndiscard pinned.unpin()\n</code></pre>"},{"location":"guide/integration/#retiring-too-early","title":"Retiring Too Early","text":"<pre><code># WRONG - retire before unlinking\nlet ready = retireReady(pinned)\ndiscard ready.retire(ptr, destroy)\nqueue.head.store(newHead, moRelease)\n\n# RIGHT - retire after unlinking\nqueue.head.store(newHead, moRelease)\nlet ready = retireReady(pinned)\ndiscard ready.retire(ptr, destroy)\n</code></pre>"},{"location":"guide/integration/#sharing-handles","title":"Sharing Handles","text":"<pre><code># WRONG - sharing handle between threads\nvar sharedHandle: ThreadHandle[64]\n\nproc thread1() {.thread.} =\n  sharedHandle = registerThread(addr manager)  # BAD!\n\n# RIGHT - each thread has own handle\nproc thread1() {.thread.} =\n  let handle = registerThread(addr manager)  # GOOD!\n</code></pre>"},{"location":"guide/integration/#performance-tips","title":"Performance Tips","text":"<ol> <li>Batch operations: Pin once for multiple operations</li> <li>Amortize reclamation: Reclaim every N operations</li> <li>Dedicated reclaimer: Use background thread for reclamation</li> <li>Minimize pinning: Only pin when accessing shared data</li> <li>Avoid blocking: Don't block while pinned</li> </ol>"},{"location":"guide/integration/#next-steps","title":"Next Steps","text":"<ul> <li>Review API reference</li> <li>Study complete examples in the repository</li> <li>Benchmark your integration</li> </ul>"},{"location":"guide/neutralization/","title":"Neutralization","text":""},{"location":"guide/neutralization/#neutralization","title":"Neutralization","text":"<p>Understanding the signal-based neutralization protocol.</p>"},{"location":"guide/neutralization/#overview","title":"Overview","text":"<p>Neutralization solves the stalled thread problem: what happens when a thread stays pinned for a long time? Without intervention, it blocks reclamation and memory accumulates unboundedly.</p> <p>DEBRA+ uses POSIX signals to neutralize stalled threads, allowing epoch advancement and bounded memory.</p>"},{"location":"guide/neutralization/#the-stalled-thread-problem","title":"The Stalled Thread Problem","text":""},{"location":"guide/neutralization/#scenario","title":"Scenario","text":"<pre><code>Thread 1: Pinned at epoch 100, doing long computation\nThread 2: Advanced to epoch 105\nThread 3: Advanced to epoch 105\n\nSafe epoch = min(100, 105, 105) = 100\nObjects retired at epoch &lt; 99 can be freed\n\nBut Thread 1 is still at 100, blocking reclamation!\n</code></pre> <p>If Thread 1 stays pinned for minutes/hours:</p> <ul> <li>Reclamation is blocked indefinitely</li> <li>Memory accumulates in limbo bags</li> <li>System may run out of memory</li> </ul>"},{"location":"guide/neutralization/#signal-based-neutralization","title":"Signal-Based Neutralization","text":""},{"location":"guide/neutralization/#how-it-works","title":"How It Works","text":"<ol> <li>Detection: Reclamation detects thread pinned at old epoch</li> <li>Signal: Send SIGUSR1 to stalled thread's OS process</li> <li>Handler: Signal handler sets neutralization flag</li> <li>Check: Thread checks flag when it unpins</li> <li>Acknowledge: Thread acknowledges neutralization</li> <li>Advance: Safe epoch can now advance past stalled thread</li> </ol>"},{"location":"guide/neutralization/#signal-handler-setup","title":"Signal Handler Setup","text":"<p>The signal handler is installed during manager initialization:</p> <pre><code>proc neutralizationHandler(sig: cint) {.noconv.} =\n  # Called when SIGUSR1 received\n  # Set neutralization flag for this thread\n  let tid = pthread_self()\n  # ... find thread slot by OS thread ID ...\n  manager.threads[idx].neutralized.store(true, moRelease)\n</code></pre>"},{"location":"guide/neutralization/#neutralization-lifecycle","title":"Neutralization Lifecycle","text":""},{"location":"guide/neutralization/#1-detection-phase","title":"1. Detection Phase","text":"<p>During reclamation, check for stalled threads:</p> <pre><code>let globalEpoch = manager.globalEpoch.load(moAcquire)\nlet threshold = globalEpoch - 2  # Stalled if 2+ epochs behind\n\nfor i in 0..&lt;MaxThreads:\n  if manager.threads[i].pinned.load(moAcquire):\n    let threadEpoch = manager.threads[i].epoch.load(moAcquire)\n    if threadEpoch &lt; threshold:\n      # Thread i is stalled - neutralize it\n      neutralizeThread(i)\n</code></pre>"},{"location":"guide/neutralization/#2-signal-delivery","title":"2. Signal Delivery","text":"<p>Send SIGUSR1 to the stalled thread:</p> <pre><code>proc neutralizeThread(idx: int) =\n  let osThreadId = manager.threads[idx].osThreadId.load(moAcquire)\n  if osThreadId &gt; 0:\n    # Send signal to thread\n    discard pthread_kill(osThreadId, QuiescentSignal)\n</code></pre>"},{"location":"guide/neutralization/#3-handler-execution","title":"3. Handler Execution","text":"<p>The signal handler runs asynchronously:</p> <pre><code>proc neutralizationHandler(sig: cint) {.noconv.} =\n  # Running in context of stalled thread\n  # Set flag to notify thread it was neutralized\n  getCurrentThreadState().neutralized.store(true, moRelease)\n</code></pre>"},{"location":"guide/neutralization/#4-detection-on-unpin","title":"4. Detection on Unpin","text":"<p>The thread checks the flag when it unpins:</p> <pre><code>let pinned = handle.pin()\n# ... long computation ...\nlet result = pinned.unpin()  # Checks neutralization flag\n\nif result.kind == uNeutralized:\n  # We were neutralized during the computation\n  echo \"Thread was neutralized\"\n</code></pre>"},{"location":"guide/neutralization/#5-acknowledgment","title":"5. Acknowledgment","text":"<p>Before re-pinning, must acknowledge neutralization:</p> <pre><code>if result.kind == uNeutralized:\n  let unpinned = result.neutralized.acknowledge()\n  # Clears neutralization flag\n  # Now can pin again\n</code></pre>"},{"location":"guide/neutralization/#neutralization-states","title":"Neutralization States","text":"<p>The typestate system enforces the protocol:</p> <ol> <li>Unpinned: Normal state, can pin</li> <li>Pinned: Critical section, might be neutralized</li> <li>Neutralized: Was signaled, must acknowledge</li> <li>Unpinned: After acknowledgment, can pin again</li> </ol> <pre><code>typestate EpochGuardContext:\n  states Unpinned, Pinned, Neutralized\n  transitions:\n    Unpinned -&gt; Pinned\n    Pinned -&gt; Unpinned | Neutralized as UnpinResult\n    Neutralized -&gt; Unpinned\n</code></pre>"},{"location":"guide/neutralization/#handling-neutralization","title":"Handling Neutralization","text":""},{"location":"guide/neutralization/#automatic-handling","title":"Automatic Handling","text":"<pre><code>proc withPinnedSection[T](handle: ThreadHandle, op: proc(): T): T =\n  var done = false\n  while not done:\n    let pinned = handle.pin()\n    result = op()\n    let unpinResult = pinned.unpin()\n\n    case unpinResult.kind:\n    of uUnpinned:\n      done = true\n    of uNeutralized:\n      # Acknowledge and retry\n      discard unpinResult.neutralized.acknowledge()\n      # Loop will retry operation\n</code></pre>"},{"location":"guide/neutralization/#manual-handling","title":"Manual Handling","text":"<pre><code>let pinned = handle.pin()\n# ... computation ...\nlet result = pinned.unpin()\n\nif result.kind == uNeutralized:\n  # We were interrupted - decide what to do\n  echo \"Operation was neutralized\"\n\n  # Acknowledge\n  discard result.neutralized.acknowledge()\n\n  # Retry or handle differently\n  retryOperation()\n</code></pre>"},{"location":"guide/neutralization/#neutralization-semantics","title":"Neutralization Semantics","text":""},{"location":"guide/neutralization/#what-neutralization-means","title":"What Neutralization Means","text":"<p>Neutralization is advisory, not forceful:</p> <ul> <li>Thread is not stopped mid-computation</li> <li>Thread is not killed or interrupted</li> <li>Thread continues running normally</li> <li>Flag is checked on next unpin</li> </ul>"},{"location":"guide/neutralization/#safety-guarantees","title":"Safety Guarantees","text":"<ul> <li>Neutralization cannot corrupt memory</li> <li>Thread completes current operation safely</li> <li>Lock-free operations remain atomic</li> <li>Memory ordering is preserved</li> </ul>"},{"location":"guide/neutralization/#limitations","title":"Limitations","text":"<p>Neutralization cannot:</p> <ul> <li>Stop a thread in an infinite loop</li> <li>Interrupt blocking system calls</li> <li>Force a thread to check the flag</li> <li>Guarantee timely response</li> </ul>"},{"location":"guide/neutralization/#configuration","title":"Configuration","text":""},{"location":"guide/neutralization/#neutralization-threshold","title":"Neutralization Threshold","text":"<p>How far behind before neutralizing?</p> <pre><code>const NeutralizationThreshold = 2  # Epochs\n\n# Thread pinned at epoch 100\n# Global epoch is 103\n# Difference = 3 &gt; threshold\n# -&gt; Neutralize\n</code></pre> <p>Lower threshold:</p> <ul> <li>More aggressive neutralization</li> <li>Better memory bounds</li> <li>More interruptions</li> </ul> <p>Higher threshold:</p> <ul> <li>More lenient on long operations</li> <li>Higher memory usage</li> <li>Fewer interruptions</li> </ul>"},{"location":"guide/neutralization/#signal-choice","title":"Signal Choice","text":"<p>DEBRA+ uses SIGUSR1 by default:</p> <pre><code>const QuiescentSignal = SIGUSR1\n</code></pre> <p>Requirements:</p> <ul> <li>Must not be used by application</li> <li>Must not have default handler</li> <li>Must be available on platform</li> </ul>"},{"location":"guide/neutralization/#platform-considerations","title":"Platform Considerations","text":""},{"location":"guide/neutralization/#posix-systems","title":"POSIX Systems","text":"<p>Neutralization works on:</p> <ul> <li>Linux</li> <li>macOS</li> <li>BSD variants</li> <li>Other POSIX-compliant systems</li> </ul>"},{"location":"guide/neutralization/#windows","title":"Windows","text":"<p>Windows does not support pthread_kill. Alternatives:</p> <ul> <li>Use events/condition variables</li> <li>Polling-based checking</li> <li>Thread interruption APIs</li> </ul> <p>Currently nim-debra targets POSIX only.</p>"},{"location":"guide/neutralization/#best-practices","title":"Best Practices","text":""},{"location":"guide/neutralization/#keep-critical-sections-short","title":"Keep Critical Sections Short","text":"<p>Avoid neutralization by keeping pin/unpin sections minimal:</p> <pre><code># GOOD - short critical section\nlet pinned = handle.pin()\nlet node = queue.dequeue()\ndiscard pinned.unpin()\nprocessNode(node)\n\n# BAD - long critical section\nlet pinned = handle.pin()\nlet node = queue.dequeue()\nprocessNode(node)  # Long computation while pinned!\ndiscard pinned.unpin()\n</code></pre>"},{"location":"guide/neutralization/#handle-neutralization-gracefully","title":"Handle Neutralization Gracefully","text":"<p>Don't treat neutralization as an error:</p> <pre><code># GOOD - retry operation\nlet result = pinned.unpin()\nif result.kind == uNeutralized:\n  discard result.neutralized.acknowledge()\n  retryOperation()\n\n# BAD - abort on neutralization\nlet result = pinned.unpin()\nif result.kind == uNeutralized:\n  raise newException(ValueError, \"Neutralized!\")\n</code></pre>"},{"location":"guide/neutralization/#monitor-neutralization-rate","title":"Monitor Neutralization Rate","text":"<p>Track how often neutralization occurs:</p> <pre><code>var neutralizationCount = 0\n\nlet result = pinned.unpin()\nif result.kind == uNeutralized:\n  inc neutralizationCount\n  if neutralizationCount mod 100 == 0:\n    echo \"Warning: \", neutralizationCount, \" neutralizations\"\n</code></pre> <p>Frequent neutralization indicates:</p> <ul> <li>Critical sections are too long</li> <li>Operations are blocking</li> <li>Threshold is too aggressive</li> </ul>"},{"location":"guide/neutralization/#debugging-neutralization","title":"Debugging Neutralization","text":""},{"location":"guide/neutralization/#detect-stalled-threads","title":"Detect Stalled Threads","text":"<pre><code>proc findStalledThreads() =\n  let globalEpoch = manager.globalEpoch.load(moAcquire)\n  for i in 0..&lt;MaxThreads:\n    if manager.threads[i].pinned.load(moAcquire):\n      let threadEpoch = manager.threads[i].epoch.load(moAcquire)\n      let lag = globalEpoch - threadEpoch\n      if lag &gt; 2:\n        echo \"Thread \", i, \" is stalled (lag=\", lag, \")\"\n</code></pre>"},{"location":"guide/neutralization/#log-neutralization-events","title":"Log Neutralization Events","text":"<pre><code>proc neutralizationHandler(sig: cint) {.noconv.} =\n  echo \"Thread neutralized at \", epochClock()\n  getCurrentThreadState().neutralized.store(true, moRelease)\n</code></pre>"},{"location":"guide/neutralization/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about integration patterns</li> <li>Review API reference</li> </ul>"},{"location":"guide/pin-unpin/","title":"Pin/Unpin","text":""},{"location":"guide/pin-unpin/#pinunpin-protocol","title":"Pin/Unpin Protocol","text":"<p>Understanding the pin/unpin lifecycle for critical sections.</p>"},{"location":"guide/pin-unpin/#overview","title":"Overview","text":"<p>The pin/unpin protocol marks critical sections where threads access lock-free data structures. Pinning prevents reclamation of objects from the current epoch.</p>"},{"location":"guide/pin-unpin/#pin-operation","title":"Pin Operation","text":""},{"location":"guide/pin-unpin/#what-pin-does","title":"What Pin Does","text":"<p>When you call <code>handle.pin()</code>:</p> <ol> <li>Load global epoch: Read the current global epoch counter</li> <li>Clear neutralization: Reset the neutralization flag</li> <li>Store epoch: Write epoch to thread's epoch slot</li> <li>Set pinned flag: Mark thread as pinned</li> </ol> <pre><code>let pinned = handle.pin()\n</code></pre> <p>Returns a <code>Pinned[MaxThreads]</code> state that enables further operations.</p>"},{"location":"guide/pin-unpin/#memory-ordering","title":"Memory Ordering","text":"<p>Pin uses acquire-release semantics:</p> <ul> <li>Acquire: Ensures prior writes by other threads are visible</li> <li>Release: Ensures our writes are visible to other threads</li> </ul> <p>This establishes the happens-before relationship needed for safe concurrent access.</p>"},{"location":"guide/pin-unpin/#unpin-operation","title":"Unpin Operation","text":""},{"location":"guide/pin-unpin/#what-unpin-does","title":"What Unpin Does","text":"<p>When you call <code>pinned.unpin()</code>:</p> <ol> <li>Clear pinned flag: Mark thread as no longer pinned</li> <li>Check neutralization: Read the neutralization flag</li> <li>Return result: Either <code>Unpinned</code> or <code>Neutralized</code> state</li> </ol> <pre><code>let result = pinned.unpin()\ncase result.kind:\nof uUnpinned:\n  # Normal unpin - continue\n  discard\nof uNeutralized:\n  # We were neutralized - must acknowledge\n  let unpinned = result.neutralized.acknowledge()\n</code></pre>"},{"location":"guide/pin-unpin/#neutralization-handling","title":"Neutralization Handling","text":"<p>If the thread was neutralized while pinned (received SIGUSR1), unpin returns a <code>Neutralized</code> state. You must acknowledge this before re-pinning:</p> <pre><code>let result = pinned.unpin()\nif result.kind == uNeutralized:\n  let unpinned = result.neutralized.acknowledge()\n  # Now can pin again\n</code></pre>"},{"location":"guide/pin-unpin/#critical-section-pattern","title":"Critical Section Pattern","text":"<p>Standard pattern for critical sections:</p> <pre><code># Enter critical section\nlet pinned = handle.pin()\n\n# Access lock-free data structures\nlet value = queue.dequeue()\nlet node = list.search(key)\n\n# Exit critical section\nlet result = pinned.unpin()\n\n# Handle neutralization if needed\nif result.kind == uNeutralized:\n  discard result.neutralized.acknowledge()\n</code></pre>"},{"location":"guide/pin-unpin/#what-can-you-do-while-pinned","title":"What Can You Do While Pinned?","text":"<p>While pinned, you can:</p> <ul> <li>Read shared memory from lock-free structures</li> <li>Perform CAS operations to modify shared state</li> <li>Retire objects that have been removed</li> <li>Access multiple structures in same critical section</li> </ul> <pre><code>let pinned = handle.pin()\n\n# Multiple operations in one critical section\nlet value1 = queue1.dequeue()\nlet value2 = queue2.dequeue()\n\n# Retire both\nlet ready1 = retireReady(pinned)\nlet retired1 = ready1.retire(value1.ptr, destroyer1)\nlet ready2 = retireReadyFromRetired(retired1)\nlet retired2 = ready2.retire(value2.ptr, destroyer2)\n\ndiscard pinned.unpin()\n</code></pre>"},{"location":"guide/pin-unpin/#what-you-cannot-do-while-pinned","title":"What You Cannot Do While Pinned","text":"<p>Avoid these while pinned:</p> <ul> <li>Blocking operations: Don't hold locks, wait on condition variables</li> <li>Long computations: Keep critical sections short</li> <li>I/O operations: Don't do file/network I/O while pinned</li> <li>Sleeping: Don't call sleep or delay functions</li> </ul> <p>Why? Pinning blocks epoch advancement and prevents reclamation. Long critical sections waste memory.</p>"},{"location":"guide/pin-unpin/#critical-section-duration","title":"Critical Section Duration","text":"<p>Keep critical sections minimal:</p> <pre><code># BAD - long critical section\nlet pinned = handle.pin()\nlet node = queue.dequeue()\nprocessNode(node)  # Long processing\nsaveToDatabase(node)  # I/O operation\ndiscard pinned.unpin()\n\n# GOOD - minimal critical section\nlet pinned = handle.pin()\nlet node = queue.dequeue()\ndiscard pinned.unpin()\n\n# Process outside critical section\nprocessNode(node)\nsaveToDatabase(node)\n</code></pre>"},{"location":"guide/pin-unpin/#nested-critical-sections","title":"Nested Critical Sections","text":"<p>Currently, nested pin/unpin is not supported:</p> <pre><code># NOT SUPPORTED\nlet pinned1 = handle.pin()\nlet pinned2 = handle.pin()  # Compile error!\n</code></pre> <p>If you need to exit and re-enter, unpin first:</p> <pre><code>let pinned1 = handle.pin()\nlet value1 = queue1.dequeue()\ndiscard pinned1.unpin()\n\n# Re-pin for second operation\nlet pinned2 = handle.pin()\nlet value2 = queue2.dequeue()\ndiscard pinned2.unpin()\n</code></pre>"},{"location":"guide/pin-unpin/#performance-considerations","title":"Performance Considerations","text":"<p>Pin/unpin overhead:</p> <ul> <li>Pin: 1 atomic load, 1 atomic store, 2 relaxed stores (~10-20ns)</li> <li>Unpin: 1 relaxed store, 1 atomic load (~5-10ns)</li> <li>Total: ~15-30ns per critical section</li> </ul> <p>This is negligible compared to lock-free operation costs. However:</p> <ul> <li>Don't pin/unpin in tight loops if not needed</li> <li>Batch operations when possible</li> <li>Keep critical sections focused</li> </ul>"},{"location":"guide/pin-unpin/#typestate-guarantees","title":"Typestate Guarantees","text":"<p>The typestate system enforces:</p> <ol> <li>Cannot retire unpinned: Must be in <code>Pinned</code> state to retire objects</li> <li>Cannot double-pin: Once pinned, cannot pin again without unpinning</li> <li>Must acknowledge neutralization: Cannot pin after neutralization without acknowledging</li> </ol> <p>These are compile-time guarantees - if it compiles, the protocol is correct.</p>"},{"location":"guide/pin-unpin/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about retiring objects</li> <li>Understand neutralization</li> <li>See integration examples</li> </ul>"},{"location":"guide/reclamation/","title":"Reclamation","text":""},{"location":"guide/reclamation/#reclamation","title":"Reclamation","text":"<p>Understanding safe memory reclamation in DEBRA+.</p>"},{"location":"guide/reclamation/#overview","title":"Overview","text":"<p>Reclamation is the process of safely freeing retired objects. The reclamation system walks thread-local limbo bags and frees objects from old epochs that are no longer accessible.</p>"},{"location":"guide/reclamation/#basic-reclamation","title":"Basic Reclamation","text":""},{"location":"guide/reclamation/#attempt-reclamation","title":"Attempt Reclamation","text":"<pre><code>let result = reclaimStart(addr manager)\n  .loadEpochs()\n  .checkSafe()\n\nif result.kind == rReclaimReady:\n  let count = result.reclaimready.tryReclaim()\n  echo \"Reclaimed \", count, \" objects\"\n</code></pre>"},{"location":"guide/reclamation/#reclamation-steps","title":"Reclamation Steps","text":"<ol> <li>Start: Begin reclamation process</li> <li>Load epochs: Read global epoch and all thread epochs</li> <li>Check safety: Determine if any epochs are safe to reclaim</li> <li>Try reclaim: Walk limbo bags and free eligible objects</li> </ol>"},{"location":"guide/reclamation/#epoch-safety","title":"Epoch Safety","text":""},{"location":"guide/reclamation/#computing-safe-epoch","title":"Computing Safe Epoch","text":"<p>The safe epoch is the minimum of all pinned thread epochs:</p> <pre><code>Global Epoch: 100\nThread 1: pinned at 98\nThread 2: pinned at 100\nThread 3: unpinned\nThread 4: pinned at 99\n\nSafe Epoch = min(98, 100, 99) = 98\n</code></pre>"},{"location":"guide/reclamation/#reclamation-rule","title":"Reclamation Rule","text":"<p>Objects retired in epoch E are safe to reclaim if:</p> <pre><code>E &lt; safeEpoch - 1\n</code></pre> <p>Why <code>-1</code>? Ensures at least one full epoch has passed since retirement.</p>"},{"location":"guide/reclamation/#reclamation-process","title":"Reclamation Process","text":""},{"location":"guide/reclamation/#walking-limbo-bags","title":"Walking Limbo Bags","text":"<p>Reclamation walks bags from oldest (tail) to newest (head):</p> <pre><code>Scan direction: &lt;----\n\ncurrentBag --&gt; [epoch=100, count=23] --&gt; [epoch=99, count=64] --&gt; [epoch=97, count=64]\n                                                                   ^\n                                                              limboBagTail\n                                                              (oldest)\n</code></pre> <p>For each bag:</p> <ol> <li>Check epoch: Is <code>bag.epoch &lt; safeEpoch - 1</code>?</li> <li>If safe: Call destructors, free bag, continue</li> <li>If not safe: Stop scanning (newer bags are also not safe)</li> </ol>"},{"location":"guide/reclamation/#calling-destructors","title":"Calling Destructors","text":"<p>For each object in a safe bag:</p> <pre><code>for i in 0..&lt;bag.count:\n  let obj = bag.objects[i]\n  if obj.destructor != nil:\n    obj.destructor(obj.data)\n</code></pre> <p>The destructor receives the original pointer and performs cleanup.</p>"},{"location":"guide/reclamation/#reclamation-scheduling","title":"Reclamation Scheduling","text":""},{"location":"guide/reclamation/#when-to-reclaim","title":"When to Reclaim","text":"<p>Reclamation can happen:</p> <ol> <li>Periodically: Background thread calls reclaim on a timer</li> <li>After operations: Attempt reclaim after N retirements</li> <li>On memory pressure: When memory usage exceeds threshold</li> <li>During idle: When threads have no work</li> </ol>"},{"location":"guide/reclamation/#frequency-trade-offs","title":"Frequency Trade-offs","text":"<p>Too frequent:</p> <ul> <li>Wastes CPU checking epochs</li> <li>Interferes with real work</li> <li>Most checks find nothing to reclaim</li> </ul> <p>Too infrequent:</p> <ul> <li>Accumulates memory</li> <li>Risk of OOM if threads stall</li> <li>Longer pause when reclaim happens</li> </ul> <p>Recommended: Every 100-1000 operations or every 10-100ms.</p>"},{"location":"guide/reclamation/#reclamation-patterns","title":"Reclamation Patterns","text":""},{"location":"guide/reclamation/#background-reclamation-thread","title":"Background Reclamation Thread","text":"<pre><code>var shouldShutdown = false\n\nproc reclaimThread() {.thread.} =\n  while not shouldShutdown:\n    let result = reclaimStart(addr manager)\n      .loadEpochs()\n      .checkSafe()\n\n    if result.kind == rReclaimReady:\n      discard result.reclaimready.tryReclaim()\n\n    sleep(10)  # 10ms between attempts\n\nvar reclaimer: Thread[void]\ncreateThread(reclaimer, reclaimThread)\n</code></pre>"},{"location":"guide/reclamation/#periodic-reclamation","title":"Periodic Reclamation","text":"<pre><code>var opCount = 0\n\nproc doOperation() =\n  # ... perform lock-free operation ...\n\n  inc opCount\n  if opCount mod 100 == 0:\n    # Every 100 operations\n    let result = reclaimStart(addr manager)\n      .loadEpochs()\n      .checkSafe()\n    if result.kind == rReclaimReady:\n      discard result.reclaimready.tryReclaim()\n</code></pre>"},{"location":"guide/reclamation/#threshold-based-reclamation","title":"Threshold-Based Reclamation","text":"<pre><code>proc retireWithReclaim(handle: ThreadHandle, ptr: pointer, destructor: Destructor) =\n  let pinned = handle.pin()\n  let ready = retireReady(pinned)\n  discard ready.retire(ptr, destructor)\n  discard pinned.unpin()\n\n  # Count objects in limbo\n  var total = 0\n  var bag = manager.threads[handle.idx].limboBagHead\n  while bag != nil:\n    total += bag.count\n    bag = bag.next\n\n  # Reclaim if over threshold\n  if total &gt; 1000:\n    let result = reclaimStart(addr manager)\n      .loadEpochs()\n      .checkSafe()\n    if result.kind == rReclaimReady:\n      discard result.reclaimready.tryReclaim()\n</code></pre>"},{"location":"guide/reclamation/#blocked-reclamation","title":"Blocked Reclamation","text":""},{"location":"guide/reclamation/#when-reclamation-blocks","title":"When Reclamation Blocks","text":"<p>If <code>safeEpoch &lt;= 1</code>, reclamation is blocked:</p> <pre><code>let result = reclaimStart(addr manager)\n  .loadEpochs()\n  .checkSafe()\n\nif result.kind == rReclaimBlocked:\n  # No epochs are safe to reclaim yet\n  # Either:\n  # - All threads pinned at current epoch\n  # - Only one epoch has passed since start\n  discard\n</code></pre> <p>This is normal in the first few epochs after startup.</p>"},{"location":"guide/reclamation/#handling-blocked-reclamation","title":"Handling Blocked Reclamation","text":"<p>Options:</p> <ol> <li>Advance epoch: Trigger epoch advancement to move forward</li> <li>Wait: Try again later</li> <li>Neutralize: If a thread is stalled, neutralize it</li> </ol>"},{"location":"guide/reclamation/#multi-thread-reclamation","title":"Multi-Thread Reclamation","text":""},{"location":"guide/reclamation/#per-thread-reclamation","title":"Per-Thread Reclamation","text":"<p>Each thread can reclaim its own limbo bags:</p> <pre><code># Each thread reclaims its own bags\nproc workerThread(idx: int) =\n  let handle = registerThread(addr manager)\n\n  for i in 0..&lt;10000:\n    # ... operations ...\n\n    if i mod 100 == 0:\n      # Only scans this thread's bags\n      let result = reclaimStart(addr manager)\n        .loadEpochs()\n        .checkSafe()\n      if result.kind == rReclaimReady:\n        discard result.reclaimready.tryReclaim()\n</code></pre> <p><code>tryReclaim()</code> scans all thread slots, but only reclaims bags belonging to each thread.</p>"},{"location":"guide/reclamation/#global-reclamation","title":"Global Reclamation","text":"<p>Alternatively, a single reclamation thread can reclaim for all threads:</p> <pre><code>proc globalReclaimer() {.thread.} =\n  while not shutdown:\n    let result = reclaimStart(addr manager)\n      .loadEpochs()\n      .checkSafe()\n\n    if result.kind == rReclaimReady:\n      # Reclaims bags from all threads\n      discard result.reclaimready.tryReclaim()\n\n    sleep(10)\n</code></pre> <p>This centralizes reclamation but adds contention.</p>"},{"location":"guide/reclamation/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guide/reclamation/#reclamation-cost","title":"Reclamation Cost","text":"<ul> <li>Load epochs: O(m) where m = max threads</li> <li>Walk bags: O(n) where n = retired objects</li> <li>Call destructors: O(n)</li> <li>Total: O(m + n)</li> </ul>"},{"location":"guide/reclamation/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Batch reclamation: Don't reclaim after every operation</li> <li>Amortize cost: Spread over many operations</li> <li>Separate thread: Dedicate a thread to reclamation</li> <li>Threshold: Only reclaim when enough objects accumulated</li> </ol>"},{"location":"guide/reclamation/#memory-vs-cpu-trade-off","title":"Memory vs CPU Trade-off","text":"<ul> <li>Frequent reclamation: Lower memory, higher CPU</li> <li>Infrequent reclamation: Higher memory, lower CPU</li> </ul> <p>Tune based on your workload.</p>"},{"location":"guide/reclamation/#debugging-reclamation","title":"Debugging Reclamation","text":""},{"location":"guide/reclamation/#check-limbo-bag-state","title":"Check Limbo Bag State","text":"<pre><code>proc dumpLimboBags(handle: ThreadHandle) =\n  echo \"Thread \", handle.idx, \" limbo bags:\"\n  var bag = manager.threads[handle.idx].limboBagHead\n  var bagNum = 0\n  while bag != nil:\n    echo \"  Bag \", bagNum, \": epoch=\", bag.epoch, \" count=\", bag.count\n    inc bagNum\n    bag = bag.next\n</code></pre>"},{"location":"guide/reclamation/#monitor-reclamation-rate","title":"Monitor Reclamation Rate","text":"<pre><code>var totalReclaimed = 0\nvar attempts = 0\n\nproc monitoredReclaim() =\n  inc attempts\n  let result = reclaimStart(addr manager)\n    .loadEpochs()\n    .checkSafe()\n\n  if result.kind == rReclaimReady:\n    let count = result.reclaimready.tryReclaim()\n    totalReclaimed += count\n    echo \"Reclaimed \", count, \" objects (\", totalReclaimed, \" total in \", attempts, \" attempts)\"\n</code></pre>"},{"location":"guide/reclamation/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about neutralization</li> <li>Understand integration patterns</li> </ul>"},{"location":"guide/retiring-objects/","title":"Retiring Objects","text":""},{"location":"guide/retiring-objects/#retiring-objects","title":"Retiring Objects","text":"<p>Understanding how to retire objects for safe reclamation.</p>"},{"location":"guide/retiring-objects/#overview","title":"Overview","text":"<p>When you remove an object from a lock-free data structure, you cannot immediately free it - other threads might still be accessing it. Instead, you retire the object, marking it for later reclamation when safe.</p>"},{"location":"guide/retiring-objects/#basic-retirement","title":"Basic Retirement","text":""},{"location":"guide/retiring-objects/#retire-an-object","title":"Retire an Object","text":"<p>You must be pinned to retire objects:</p> <pre><code>let pinned = handle.pin()\n\n# Remove node from lock-free queue\nlet node = queue.dequeue()\n\n# Retire it for later reclamation\nlet ready = retireReady(pinned)\nlet retired = ready.retire(cast[pointer](node), nodeDestructor)\n\ndiscard pinned.unpin()\n</code></pre> <p>The <code>retire()</code> call takes:</p> <ol> <li>Data pointer: Pointer to the object being retired</li> <li>Destructor: Function to call when reclaiming</li> </ol>"},{"location":"guide/retiring-objects/#destructors","title":"Destructors","text":""},{"location":"guide/retiring-objects/#destructor-signature","title":"Destructor Signature","text":"<p>Destructors must have this signature:</p> <pre><code>proc myDestructor(p: pointer) {.nimcall.}\n</code></pre>"},{"location":"guide/retiring-objects/#simple-destructor","title":"Simple Destructor","text":"<p>For objects allocated with <code>alloc</code>:</p> <pre><code>proc simpleDestructor(p: pointer) {.nimcall.} =\n  dealloc(p)\n</code></pre>"},{"location":"guide/retiring-objects/#complex-destructor","title":"Complex Destructor","text":"<p>For objects with cleanup needs:</p> <pre><code>type Node = object\n  value: string\n  data: seq[int]\n\nproc nodeDestructor(p: pointer) {.nimcall.} =\n  let node = cast[ptr Node](p)\n  # Clean up resources\n  node.value = \"\"\n  node.data.setLen(0)\n  # Free memory\n  dealloc(node)\n</code></pre>"},{"location":"guide/retiring-objects/#nil-destructor","title":"Nil Destructor","text":"<p>If the object needs no cleanup (e.g., static memory):</p> <pre><code>let retired = ready.retire(somePtr, nil)\n</code></pre>"},{"location":"guide/retiring-objects/#multiple-retirements","title":"Multiple Retirements","text":""},{"location":"guide/retiring-objects/#retiring-multiple-objects","title":"Retiring Multiple Objects","text":"<p>To retire multiple objects while pinned:</p> <pre><code>let pinned = handle.pin()\n\nvar ready = retireReady(pinned)\nfor i in 0..&lt;10:\n  let node = queue.dequeue()\n  let retired = ready.retire(cast[pointer](node), nodeDestructor)\n  ready = retireReadyFromRetired(retired)\n\ndiscard pinned.unpin()\n</code></pre> <p>The <code>retireReadyFromRetired()</code> function transitions back to <code>RetireReady</code> state for the next retirement.</p>"},{"location":"guide/retiring-objects/#limbo-bags","title":"Limbo Bags","text":""},{"location":"guide/retiring-objects/#how-retirement-works","title":"How Retirement Works","text":"<p>Retired objects are added to thread-local limbo bags:</p> <ol> <li>Check current bag: Is there a bag with space?</li> <li>Allocate if needed: Create new bag if current is full (64 objects)</li> <li>Store object: Add pointer and destructor to bag</li> <li>Record epoch: Tag bag with current epoch</li> <li>Link bags: Chain bags together for later reclamation</li> </ol>"},{"location":"guide/retiring-objects/#bag-structure","title":"Bag Structure","text":"<pre><code>ThreadState.currentBag --&gt; [Bag: epoch=5, count=23]\n                           next |\n                                v\n                           [Bag: epoch=4, count=64]\n                           next |\n                                v\nThreadState.limboBagTail   [Bag: epoch=3, count=64]\n</code></pre>"},{"location":"guide/retiring-objects/#bag-size","title":"Bag Size","text":"<p>Each limbo bag holds up to 64 objects. When full, a new bag is allocated. This batching:</p> <ul> <li>Reduces allocation overhead</li> <li>Improves cache locality</li> <li>Simplifies reclamation</li> </ul>"},{"location":"guide/retiring-objects/#retirement-and-epochs","title":"Retirement and Epochs","text":""},{"location":"guide/retiring-objects/#epoch-tagging","title":"Epoch Tagging","text":"<p>Objects are retired at a specific epoch:</p> <pre><code># Global epoch is 100\nlet pinned = handle.pin()  # Pins at epoch 100\nlet retired = retireReady(pinned).retire(ptr, destructor)\n# Object tagged with epoch 100\n</code></pre>"},{"location":"guide/retiring-objects/#reclamation-safety","title":"Reclamation Safety","text":"<p>Objects are safe to reclaim when all threads have advanced past their retirement epoch:</p> <ul> <li>Object retired at epoch 100</li> <li>All threads now at epoch 103+</li> <li>Safe to reclaim (no thread can be accessing it)</li> </ul>"},{"location":"guide/retiring-objects/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/retiring-objects/#queue-node-retirement","title":"Queue Node Retirement","text":"<pre><code>type QueueNode = object\n  value: int\n  next: Atomic[ptr QueueNode]\n\nproc destroyQueueNode(p: pointer) {.nimcall.} =\n  dealloc(p)\n\nproc dequeue(queue: var LockFreeQueue): int =\n  let pinned = queue.handle.pin()\n\n  # Dequeue operation (simplified)\n  let head = queue.head.load(moAcquire)\n  let value = head.value\n  queue.head.store(head.next.load(moRelaxed), moRelease)\n\n  # Retire old head\n  let ready = retireReady(pinned)\n  discard ready.retire(cast[pointer](head), destroyQueueNode)\n\n  discard pinned.unpin()\n  result = value\n</code></pre>"},{"location":"guide/retiring-objects/#list-node-retirement","title":"List Node Retirement","text":"<pre><code>proc removeNode(list: var LockFreeList, key: int) =\n  let pinned = list.handle.pin()\n\n  # Find and remove node\n  var pred = list.head\n  var curr = pred.next.load(moAcquire)\n\n  while curr != nil:\n    if curr.key == key:\n      # Unlink node\n      pred.next.store(curr.next.load(moRelaxed), moRelease)\n\n      # Retire it\n      let ready = retireReady(pinned)\n      discard ready.retire(cast[pointer](curr), destroyListNode)\n      break\n\n    pred = curr\n    curr = curr.next.load(moAcquire)\n\n  discard pinned.unpin()\n</code></pre>"},{"location":"guide/retiring-objects/#batch-retirement","title":"Batch Retirement","text":"<pre><code>proc clearAll(queue: var LockFreeQueue) =\n  let pinned = queue.handle.pin()\n  var ready = retireReady(pinned)\n\n  var node = queue.head.load(moAcquire)\n  while node != nil:\n    let next = node.next.load(moRelaxed)\n\n    # Retire this node\n    let retired = ready.retire(cast[pointer](node), destroyQueueNode)\n    ready = retireReadyFromRetired(retired)\n\n    node = next\n\n  queue.head.store(nil, moRelease)\n  discard pinned.unpin()\n</code></pre>"},{"location":"guide/retiring-objects/#best-practices","title":"Best Practices","text":""},{"location":"guide/retiring-objects/#do-retire-objects-that","title":"Do Retire Objects That:","text":"<ul> <li>Were removed from shared data structures</li> <li>Are no longer reachable via shared pointers</li> <li>Might still be accessed by concurrent threads</li> </ul>"},{"location":"guide/retiring-objects/#dont-retire-objects-that","title":"Don't Retire Objects That:","text":"<ul> <li>Are still reachable in the data structure</li> <li>Are local to the current thread (just free them)</li> <li>Are static/global (they're never freed)</li> </ul>"},{"location":"guide/retiring-objects/#retirement-timing","title":"Retirement Timing","text":"<pre><code># WRONG - retire before unlinking\nlet retired = ready.retire(ptr, destructor)\nqueue.head.store(newHead, moRelease)\n\n# RIGHT - retire after unlinking\nqueue.head.store(newHead, moRelease)\nlet retired = ready.retire(ptr, destructor)\n</code></pre> <p>Always unlink first, then retire. Otherwise other threads might access freed memory.</p>"},{"location":"guide/retiring-objects/#memory-overhead","title":"Memory Overhead","text":"<p>Each retired object costs:</p> <ul> <li>Pointer: 8 bytes</li> <li>Destructor pointer: 8 bytes</li> <li>Total: 16 bytes per retired object</li> </ul> <p>Plus limbo bag overhead:</p> <ul> <li>Bag header: ~32 bytes</li> <li>Holds 64 objects: 64 * 16 = 1024 bytes</li> <li>Overhead per object: ~1.5%</li> </ul>"},{"location":"guide/retiring-objects/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about reclamation</li> <li>Understand neutralization</li> <li>See integration examples</li> </ul>"},{"location":"guide/thread-registration/","title":"Thread Registration","text":""},{"location":"guide/thread-registration/#thread-registration","title":"Thread Registration","text":"<p>Understanding thread registration lifecycle in DEBRA+.</p>"},{"location":"guide/thread-registration/#overview","title":"Overview","text":"<p>Each thread must register with the DEBRA manager before performing pin/unpin operations. Registration allocates a thread slot and provides a handle for all subsequent operations.</p>"},{"location":"guide/thread-registration/#registration-process","title":"Registration Process","text":""},{"location":"guide/thread-registration/#1-acquire-slot","title":"1. Acquire Slot","text":"<p>The registration process begins by finding an available thread slot:</p> <pre><code>let handle = registerThread(addr manager)\n</code></pre> <p>This performs several steps:</p> <ol> <li>Search for an unused slot in the thread array</li> <li>Claim the slot by setting the OS thread ID</li> <li>Initialize the slot's epoch and flags</li> <li>Return a handle containing the slot index</li> </ol>"},{"location":"guide/thread-registration/#2-thread-handle","title":"2. Thread Handle","text":"<p>The returned <code>ThreadHandle</code> contains:</p> <pre><code>type ThreadHandle[MaxThreads: static int] = object\n  idx: int  # Slot index in manager.threads array\n  manager: ptr DebraManager[MaxThreads]\n</code></pre> <p>This handle is used for all subsequent operations:</p> <ul> <li><code>handle.pin()</code> - Enter critical section</li> <li><code>retireObject(pinned, ...)</code> - Retire objects</li> <li>Reclamation checks thread state via handle</li> </ul>"},{"location":"guide/thread-registration/#thread-limits","title":"Thread Limits","text":"<p>The manager is created with a compile-time maximum thread count:</p> <pre><code>var manager: DebraManager[64]  # Support up to 64 threads\n</code></pre> <p>Attempting to register more threads than the limit will fail:</p> <pre><code># This will raise an error if all 64 slots are occupied\nlet handle = registerThread(addr manager)\n</code></pre>"},{"location":"guide/thread-registration/#registration-states","title":"Registration States","text":"<p>Thread registration follows a typestate protocol:</p> <ol> <li>Unregistered: Thread has not registered yet</li> <li>SlotClaimed: Thread has claimed a slot</li> <li>Registered: Thread is fully registered and can pin</li> </ol>"},{"location":"guide/thread-registration/#per-thread-state","title":"Per-Thread State","text":"<p>Each thread slot maintains:</p> <pre><code>type ThreadState[MaxThreads: static int] = object\n  epoch: Atomic[uint64]        # Current/pinned epoch\n  pinned: Atomic[bool]         # Is thread pinned?\n  neutralized: Atomic[bool]    # Neutralization flag\n  osThreadId: Atomic[Pid]      # OS thread ID\n  currentBag: ptr LimboBag     # Current limbo bag\n  limboBagHead: ptr LimboBag   # Head of limbo bag list\n  limboBagTail: ptr LimboBag   # Tail of limbo bag list\n</code></pre>"},{"location":"guide/thread-registration/#thread-deregistration","title":"Thread Deregistration","text":"<p>When a thread finishes, it should deregister:</p> <pre><code># Future API - not yet implemented\nlet shutdown = handle.deregister()\n</code></pre> <p>Deregistration:</p> <ol> <li>Ensures thread is unpinned</li> <li>Reclaims any remaining limbo bags</li> <li>Clears the OS thread ID to free the slot</li> </ol>"},{"location":"guide/thread-registration/#registration-example","title":"Registration Example","text":"<pre><code>import debra\n\n# Initialize manager\nvar manager: DebraManager[4]\ndiscard uninitializedManager(addr manager).initialize()\n\n# Worker thread\nproc worker() {.thread.} =\n  # Register this thread\n  let handle = registerThread(addr manager)\n\n  # Now we can use DEBRA operations\n  for i in 0..&lt;1000:\n    let pinned = handle.pin()\n    # ... work ...\n    discard pinned.unpin()\n\n  # Thread exits - deregistration automatic in future\n\n# Start threads\nvar threads: array[4, Thread[void]]\nfor i in 0..&lt;4:\n  createThread(threads[i], worker)\nfor i in 0..&lt;4:\n  joinThreads(threads[i])\n</code></pre>"},{"location":"guide/thread-registration/#best-practices","title":"Best Practices","text":"<ol> <li>Register once per thread: Don't register multiple times</li> <li>Keep handle alive: Store the handle for the thread's lifetime</li> <li>Don't share handles: Each thread needs its own handle</li> <li>Respect limits: Don't exceed MaxThreads parameter</li> </ol>"},{"location":"guide/thread-registration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/thread-registration/#no-available-thread-slots","title":"\"No available thread slots\"","text":"<p>All slots are occupied. Either:</p> <ul> <li>Increase <code>MaxThreads</code> when creating the manager</li> <li>Ensure threads deregister when done</li> <li>Check for thread leaks</li> </ul>"},{"location":"guide/thread-registration/#thread-already-registered","title":"\"Thread already registered\"","text":"<p>A thread tried to register twice. Registration is per-thread, not per-operation.</p>"},{"location":"guide/thread-registration/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about pin/unpin lifecycle</li> <li>Understand retiring objects</li> </ul>"}]}